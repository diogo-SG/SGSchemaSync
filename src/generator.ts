import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now

// Helper to generate a TS identifier (e.g., for function names, types)
function toTsIdentifier(str: string): string {
  if (!str) return "_"; // Handle empty or null strings
  // Remove leading/trailing non-alphanumeric, replace separators with underscores
  const cleaned = str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "").replace(/[^a-zA-Z0-9_]+/g, "_");
  // Ensure it starts with a letter or underscore if the first char was numeric or if empty after cleaning
  if (!cleaned || /^[0-9]/.test(cleaned)) {
    return `_${cleaned}`;
  }
  return cleaned;
}

// Helper to generate a PascalCase type name
function toPascalCase(str: string): string {
  if (!str) return "Type"; // Handle empty or null strings
  // Correctly handle splitting and mapping
  return str
    .split(/[^a-zA-Z0-9]/)
    .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : ""))
    .join("");
}

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPISpec | OpenAPIV3.Document
): Promise<{ typesContent: string; functionsContent: string }> {
  let typesContent = `// Types for ${tagName}\n\n/* eslint-disable */\n/**\n * This file was automatically generated by api-client-generator.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run api-client-generator to regenerate this file.\n */\n`;
  let functionsContent = `// API Functions for ${tagName}\n\n`;
  functionsContent += `import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n`;
  // Generate a safe identifier for the tag import
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  functionsContent += `import * as ${tagImportName} from '../types/${sanitizedTagName}';\n\n// TODO: Add function implementations here\n`; // Placeholder for functions

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag

  console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;
    // Create a base name for types, preferring operationId
    const baseName = operationId
      ? toPascalCase(operationId)
      : toPascalCase(`${method}_${path.replace(/[^a-zA-Z0-9_]/g, "_")}`);

    // --- Generate Request Body Type ---
    if (operation.requestBody && "content" in operation.requestBody) {
      const requestBodySchema = operation.requestBody.content?.["application/json"]?.schema;
      if (requestBodySchema) {
        const typeName = `${baseName}RequestBody`;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(requestBodySchema as JSONSchema, typeName, { bannerComment: "" });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            console.warn(`    [${tagName}] Failed to generate request body type ${typeName}: ${err.message}`);
          }
        }
      }
    }

    // --- Generate Response Types (only for 2xx status codes for now) ---
    for (const statusCode in operation.responses) {
      if (statusCode.startsWith("2")) {
        // Look for 200, 201, 204 etc.
        const response = operation.responses[statusCode] as OpenAPIV3.ResponseObject;
        if (response && "content" in response && response.content?.["application/json"]?.schema) {
          const responseSchema = response.content["application/json"].schema;
          const typeName = `${baseName}Response${statusCode}`;
          if (!generatedTypeNames.has(typeName)) {
            try {
              const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
              typesContent += `\n${tsType}\n`;
              generatedTypeNames.add(typeName);
            } catch (err: any) {
              console.warn(
                `    [${tagName}] Failed to generate response type ${typeName} for status ${statusCode}: ${err.message}`
              );
            }
          }
        }
      }
    }

    // --- Generate Parameters Type (Basic Query Params Example) ---
    // TODO: Expand to handle header, path params and different types more robustly
    const queryParams = operation.parameters?.filter(
      (p) => (p as OpenAPIV3.ParameterObject).in === "query"
    ) as OpenAPIV3.ParameterObject[];
    if (queryParams && queryParams.length > 0) {
      const paramsSchema: JSONSchema = {
        type: "object",
        properties: {},
        required: [],
      };
      queryParams.forEach((p) => {
        if (paramsSchema.properties) {
          paramsSchema.properties[p.name] = p.schema || { type: "string" }; // Default to string if no schema
          if (p.required) {
            // Ensure paramsSchema.required is an array before pushing
            if (!Array.isArray(paramsSchema.required)) {
              paramsSchema.required = [];
            }
            paramsSchema.required.push(p.name); // Now this is safe
          }
        }
      });

      if (Object.keys(paramsSchema.properties || {}).length > 0) {
        const typeName = `${baseName}Parameters`;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(paramsSchema, typeName, { bannerComment: "", additionalProperties: false });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            console.warn(`    [${tagName}] Failed to generate parameters type ${typeName}: ${err.message}`);
          }
        }
      }
    }
  } // End loop through operations

  // NOTE: Formatting is removed for now. Can be added back later.

  return { typesContent, functionsContent };
}
