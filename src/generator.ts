import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now

// Helper to generate a TS identifier (e.g., for function names, types)
function toTsIdentifier(str: string): string {
  if (!str) return "_"; // Handle empty or null strings
  // Remove leading/trailing non-alphanumeric, replace separators with underscores
  const cleaned = str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "").replace(/[^a-zA-Z0-9_]+/g, "_");
  // Ensure it starts with a letter or underscore if the first char was numeric or if empty after cleaning
  if (!cleaned || /^[0-9]/.test(cleaned)) {
    return `_${cleaned}`;
  }
  return cleaned;
}

// Helper to generate a PascalCase type name
function toPascalCase(str: string): string {
  if (!str) return "Type"; // Handle empty or null strings
  // Correctly handle splitting and mapping
  return str
    .split(/[^a-zA-Z0-9]/)
    .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : ""))
    .join("");
}

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPISpec | OpenAPIV3.Document
): Promise<{ typesContent: string; functionsContent: string }> {
  let typesContent = `// Types for ${tagName}\n\n`;
  let functionsContent = `// API Functions for ${tagName}\n\n`;
  functionsContent += `import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n`;
  // Generate a safe identifier for the tag import
  const tagImportName = toTsIdentifier(tagName) + "Types";
  functionsContent += `import * as ${tagImportName} from '../types/${tagName.toLowerCase()}';\n\n`;

  // --- Sample Implementation for GET /api/venues/{venueId} ---
  const sampleOpInfo = operations.find((op) => op.path === "/api/venues/{venueId}" && op.method === "get");

  if (sampleOpInfo && tagName === "Venues") {
    console.log("    Generating sample for GET /api/venues/{venueId}");
    const operation = sampleOpInfo.operation;
    const path = sampleOpInfo.path;
    const method = sampleOpInfo.method;

    // Use operationId if available, otherwise generate one
    const baseName = operation.operationId
      ? toTsIdentifier(operation.operationId)
      : toTsIdentifier(`get_${path.replace(/[^a-zA-Z0-9_]/g, "_")}`);
    const functionName = baseName;
    const responseTypeName = toPascalCase(`${baseName}Response`);

    // --- Type Generation ---
    const successResponse = operation.responses?.["200"] as OpenAPIV3.ResponseObject;
    const schema = successResponse?.content?.["application/json"]?.schema as OpenAPIV3.SchemaObject;
    const dataSchema = schema?.properties?.data as OpenAPIV3.SchemaObject;

    let actualResponseTypeName = "any"; // Default
    if (dataSchema) {
      try {
        // Simplified compile options
        const generatedType = await compile(dataSchema as JSONSchema, responseTypeName, {
          bannerComment: "/* Auto-generated by api-client-generator */",
          additionalProperties: false,
        });
        typesContent += `\n${generatedType}\n`;
        actualResponseTypeName = responseTypeName; // Use the generated name if successful
      } catch (err: any) {
        console.error(`      Error generating type ${responseTypeName}: ${err.message}`);
      }
    } else {
      console.warn(`      Could not find suitable response schema for ${functionName}`);
    }

    // --- Function Generation ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];
    const funcParamsList: string[] = [];
    pathParams.forEach((p) => {
      funcParamsList.push(`${toTsIdentifier(p.name)}: string`); // Basic typing
    });
    funcParamsList.push(`config?: AxiosRequestConfig`);
    const funcParamsString = funcParamsList.join(",\n  "); // Corrected join separator

    const urlPath = path.replace(/\{([^}]+)\}/g, (match, paramName) => `\${${toTsIdentifier(paramName)}}`);

    // Simple string concatenation for the function body
    let functionString = `\n/**\n * ${operation.summary || ""}\n`;
    if (operation.description) {
      functionString += ` * ${operation.description.replace(/\n/g, "\n * ")}\n`; // Format description
    }
    functionString += ` */\n`;
    functionString += `export async function ${functionName}(\n  ${funcParamsString}\n`;
    functionString += `): Promise<AxiosResponse<${tagImportName}.${actualResponseTypeName}>> {\n`; // Use actualResponseTypeName
    functionString += `  const url = \`${urlPath}\`;\n`;
    functionString += `  const axiosConfig: AxiosRequestConfig = {\n`;
    functionString += `    method: '${method}',\n`;
    functionString += `    url,\n`;
    functionString += `    ...config,\n`;
    functionString += `  };\n`;
    functionString += `  return axios(axiosConfig);\n`;
    functionString += `}\n`;

    functionsContent += functionString;
  }
  // --- End Sample ---

  // TODO: Iterate through ALL operations for the tag and generate types/functions

  // NOTE: Formatting is removed for now. Can be added back later.

  return { typesContent, functionsContent };
}
