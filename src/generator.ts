import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now
import {
  toTsIdentifier,
  toPascalCase,
  getPathBasedBaseName,
  createTopLevelBanner,
  createOperationGroupBanner,
} from "./helpers/generator-helpers";

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document,
  reactQueryEnabled: boolean
): Promise<{ typesContent: string; functionsContent: string; hooksContent: string }> {
  // Create top-level banner for types file
  const typeTopBanner = createTopLevelBanner("types");
  let typesContent = `${typeTopBanner}\n\n/* eslint-disable */\n/**\n * This file was automatically generated by sg-schema-sync.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run sg-schema-sync to regenerate this file.\n */\n`;

  // Create top-level banner for functions file
  const functionTopBanner = createTopLevelBanner("functions");
  let functionsContent = `${functionTopBanner}\n\n`;

  functionsContent += `import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n`;
  // Generate a safe identifier for the tag import
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  functionsContent += `import * as ${tagImportName} from './types';\n\n`;

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag

  console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  // Initialize hooksContent
  let hooksContent = "";
  let hooksGenerated = false; // Track if any hooks are added for this tag

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;

    // BaseName for types (uses operationId or path)
    const baseNameForTypes = operationId ? toPascalCase(operationId) : getPathBasedBaseName(path);

    // --- Generate function name using new convention ---
    const endpointBaseName = getPathBasedBaseName(path); // Always use path for endpoint part
    const methodUpper = method.toUpperCase();
    const functionName = `${endpointBaseName}_${methodUpper}`;

    // Add Operation Banners to Types File (using operation summary)
    const summary = operation.summary || "No Description Provided";

    // Create banner for the operation group
    const operationGroupBanner = createOperationGroupBanner(operation.summary, method, path);

    typesContent += `\n\n${operationGroupBanner}\n`;

    // Flags and type name variables initialization
    let actualRequestBodyTypeName: string | null = null;
    let requestBodyFailed = false;
    let actualParametersTypeName: string | null = null;
    let parametersTypeFailed = false;
    // Use baseNameForTypes for generating type names
    let primaryResponseTypeName: string | null = null;
    let primaryResponseTypeGenerated = false;
    let responseTypeFailed = false;

    // --- Generate Request Body Type (uses baseNameForTypes) ---
    if (operation.requestBody && "content" in operation.requestBody) {
      const requestBodySchema = operation.requestBody.content?.["application/json"]?.schema;
      if (requestBodySchema) {
        const typeName = `${baseNameForTypes}_${methodUpper}_Request`;
        actualRequestBodyTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(requestBodySchema as JSONSchema, typeName, { bannerComment: "" });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate request body type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualRequestBodyTypeName = null;
            requestBodyFailed = true;
          }
        }
      }
    }

    // --- Generate Response Types (uses baseNameForTypes) ---
    for (const statusCode in operation.responses) {
      if (statusCode.startsWith("2")) {
        const response = operation.responses[statusCode] as OpenAPIV3.ResponseObject;
        const primarySuccessCode = method === "post" ? "201" : "200";
        const isPrimary = statusCode === primarySuccessCode;
        if (response && "content" in response && response.content?.["application/json"]?.schema) {
          const responseSchema = response.content["application/json"].schema;
          const typeName = `${baseNameForTypes}_${methodUpper}_Response${isPrimary ? "" : `_${statusCode}`}`;
          if (isPrimary) primaryResponseTypeName = typeName;
          if (!generatedTypeNames.has(typeName)) {
            try {
              const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
              typesContent += `\n${tsType}\n`;
              generatedTypeNames.add(typeName);
              if (isPrimary) primaryResponseTypeGenerated = true;
            } catch (err: any) {
              const errMsg = err.message;
              console.warn(
                `    [${tagName}] Failed to generate response type ${typeName} (status ${statusCode}): ${errMsg}`
              );
              typesContent += `\n// ⚠️ Type generation failed for ${typeName} (status ${statusCode}): ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
              if (isPrimary) responseTypeFailed = true;
            }
          } else {
            if (isPrimary) primaryResponseTypeGenerated = true;
          }
        } else if (isPrimary && !response?.content) {
          primaryResponseTypeName = "void";
          primaryResponseTypeGenerated = true;
        } else if (isPrimary) {
          console.warn(
            `    [${tagName}] No content schema for primary success ${primarySuccessCode} for ${functionName}.`
          );
          responseTypeFailed = true;
        }
      }
    }

    // --- Generate Parameters Type (uses baseNameForTypes) ---
    const queryParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "query"
      ) as OpenAPIV3.ParameterObject[]) || [];
    if (queryParams && queryParams.length > 0) {
      const paramsSchema: JSONSchema = { type: "object", properties: {}, required: [] };
      queryParams.forEach((p) => {
        if (paramsSchema.properties) {
          paramsSchema.properties[p.name] = p.schema || { type: "string" };
          if (p.required) {
            if (!Array.isArray(paramsSchema.required)) {
              paramsSchema.required = [];
            }
            paramsSchema.required.push(p.name);
          }
        }
      });
      if (Object.keys(paramsSchema.properties || {}).length > 0) {
        const typeName = `${baseNameForTypes}_${methodUpper}_Parameters`;
        actualParametersTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(paramsSchema, typeName, { bannerComment: "", additionalProperties: false });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate parameters type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualParametersTypeName = null;
            parametersTypeFailed = true;
          }
        }
      }
    }

    // --- Assemble Function ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];
    const funcParamsList: string[] = [];
    pathParams.forEach((p) => {
      funcParamsList.push(`${toTsIdentifier(p.name)}: string`);
    });
    if (actualRequestBodyTypeName) {
      funcParamsList.push(`data: ${tagImportName}.${actualRequestBodyTypeName}`);
    }
    if (actualParametersTypeName) {
      funcParamsList.push(`params?: ${tagImportName}.${actualParametersTypeName}`);
    }
    funcParamsList.push(`config?: AxiosRequestConfig`);
    const funcParamsString = funcParamsList.join(",\n  ");
    const urlPath = path.replace(/{([^}]+)}/g, (match, paramName) => `$\{${toTsIdentifier(paramName)}\}`);

    let finalResponseTypeNameForSig: string;
    if (primaryResponseTypeGenerated) {
      finalResponseTypeNameForSig =
        primaryResponseTypeName === "void"
          ? "void"
          : primaryResponseTypeName
            ? `${tagImportName}.${primaryResponseTypeName}`
            : "any";
    } else {
      finalResponseTypeNameForSig = "any";
    }

    let functionComment = "";
    if (requestBodyFailed) {
      functionComment += `// ⚠️ WARNING: Request Body type generation failed, using 'any' for data parameter if applicable. Check OpenAPI spec.\n`;
    }
    if (parametersTypeFailed) {
      functionComment += `// ⚠️ WARNING: Parameters type generation failed, using 'any' for params parameter if applicable. Check OpenAPI spec.\n`;
    }
    if (responseTypeFailed || (!primaryResponseTypeGenerated && primaryResponseTypeName !== "void")) {
      functionComment += `// ⚠️ WARNING: Response type generation failed or schema missing, using '${finalResponseTypeNameForSig}' as fallback. Check OpenAPI spec.\n`;
    }

    let functionString = "";
    if (functionComment) {
      functionString += `\n${functionComment}`;
    }
    functionString += `\n\n${operationGroupBanner}\n`;
    functionString += `/**\n * ${summary}\n`;
    if (operation.description && operation.description !== summary) {
      functionString += ` * ${operation.description.replace(/\n/g, "\n * ")}\n`;
    }
    functionString += ` */\n`;
    functionString += `export async function ${functionName}(\n  ${funcParamsString}\n`;
    functionString += `): Promise<AxiosResponse<${finalResponseTypeNameForSig}>> {\n`;
    functionString += `  const url = \`${urlPath}\`;\n`;
    functionString += `  const axiosConfig: AxiosRequestConfig = {\n`;
    functionString += `    method: '${method}',\n`;
    functionString += `    url,\n`;
    if (actualParametersTypeName) {
      functionString += `    params,\n`;
    }
    if (actualRequestBodyTypeName) {
      functionString += `    data,\n`;
    }
    functionString += `    ...config,\n`;
    functionString += `  };\n`;
    functionString += `  return axios(axiosConfig);\n`;
    functionString += `}\n`;

    functionsContent += functionString;

    // --- Generate React Query Hooks (if enabled) ---
    if (reactQueryEnabled) {
      console.log(`    [RQ Enabled] Generating hook for ${functionName}`); // Log entry
      let hookString = "";
      const queryHookParamsList: string[] = [];
      const pathParamNames = pathParams.map((p) => toTsIdentifier(p.name));
      pathParams.forEach((p) => {
        queryHookParamsList.push(`${toTsIdentifier(p.name)}: string`);
      });
      if (actualParametersTypeName) {
        queryHookParamsList.push(`params?: ${tagImportName}.${actualParametersTypeName}`);
      }
      let finalResponseTypeNameForHook: string;
      if (primaryResponseTypeGenerated) {
        finalResponseTypeNameForHook =
          primaryResponseTypeName === "void"
            ? "void"
            : primaryResponseTypeName
              ? `${tagImportName}.${primaryResponseTypeName}`
              : "any";
      } else {
        finalResponseTypeNameForHook = "any";
      }

      if (method === "get") {
        // ... (useQuery generation logic) ...
        const hookName = `use${functionName}`;
        queryHookParamsList.push(
          `options?: Omit<UseQueryOptions<${finalResponseTypeNameForHook}, AxiosError>, 'queryKey' | 'queryFn'>`
        );
        const queryKeyParts = [`'${sanitizedTagName}'`, `'${endpointBaseName}'`];
        if (pathParamNames.length > 0) {
          queryKeyParts.push(`{ ${pathParamNames.join(", ")} }`);
        }
        if (actualParametersTypeName) {
          queryKeyParts.push("params");
        }

        const operationGroupBannerForHook = createOperationGroupBanner(operation.summary, method, path);

        hookString += `\n\n${operationGroupBannerForHook}\n`;
        hookString += `export const ${hookName} = (\n  ${queryHookParamsList.join(",\n  ")}\n) => {\n`;
        hookString += `  const queryKey: QueryKey = [${queryKeyParts.join(", ")}];\n`;
        hookString += `  return useQuery<${finalResponseTypeNameForHook}, AxiosError>({\n`;
        hookString += `    queryKey,\n`;
        hookString += `    queryFn: async () => {\n`;
        const baseFuncArgsList: string[] = [...pathParamNames];
        if (actualParametersTypeName) {
          baseFuncArgsList.push("params");
        }
        hookString += `      const response = await API.${functionName}(${baseFuncArgsList.join(", ")});\n`;
        hookString += `      return response.data;\n`;
        hookString += `    },\n`;
        hookString += `    ...options,\n`;
        hookString += `  });\n`;
        hookString += `};\n`;
      } else {
        // ... (useMutation generation logic) ...
        const hookName = `use${functionName}`;
        let mutationVariablesTypeParts: string[] = [];
        pathParamNames.forEach((p) => mutationVariablesTypeParts.push(`${p}: string`));
        if (actualRequestBodyTypeName) {
          mutationVariablesTypeParts.push(`data: ${tagImportName}.${actualRequestBodyTypeName}`);
        }
        if (actualParametersTypeName) {
          mutationVariablesTypeParts.push(`params?: ${tagImportName}.${actualParametersTypeName}`);
        }
        let mutationVariablesType = "void";
        if (mutationVariablesTypeParts.length > 0) {
          mutationVariablesType = `{ ${mutationVariablesTypeParts.join("; ")} }`;
        }
        const mutationHookParamsList = [
          `options?: Omit<UseMutationOptions<${finalResponseTypeNameForHook}, AxiosError, ${mutationVariablesType}>, 'mutationFn'>`,
        ];

        const operationGroupBannerForMutationHook = createOperationGroupBanner(operation.summary, method, path);

        hookString += `\n\n${operationGroupBannerForMutationHook}\n`;
        hookString += `export const ${hookName} = (\n  ${mutationHookParamsList.join(",\n  ")}\n) => {\n`;
        hookString += `  return useMutation<${finalResponseTypeNameForHook}, AxiosError, ${mutationVariablesType}>({\n`;
        hookString += `    mutationFn: async (variables) => {\n`;
        const baseFuncArgsList: string[] = [];
        pathParamNames.forEach((p) => baseFuncArgsList.push(`variables.${p}`));
        if (actualRequestBodyTypeName) {
          baseFuncArgsList.push("variables.data");
        }
        if (actualParametersTypeName) {
          baseFuncArgsList.push("variables.params");
        }
        hookString += `      const response = await API.${functionName}(${baseFuncArgsList.join(", ")});\n`;
        hookString += `      return response.data;\n`;
        hookString += `    },\n`;
        hookString += `    ...options,\n`;
        hookString += `  });\n`;
        hookString += `};\n`;
      }

      console.log(`    [RQ] Generated hook string length: ${hookString.length}`); // Log hook string length
      if (hookString.trim()) {
        // Check if non-empty string generated
        hooksContent += hookString;
        hooksGenerated = true; // Mark that we added a hook for this tag file
        console.log(`    [RQ] hooksGenerated set to true for ${functionName}`); // Log flag set
      } else {
        console.log(`    [RQ] No hook string generated for ${functionName}`); // Log if empty
      }
    }
  } // End loop through operations

  // --- Add Imports to hooksContent if needed ---
  console.log(`  [RQ Summary] Finished loop. hooksGenerated: ${hooksGenerated}`); // Log final flag state
  if (reactQueryEnabled && hooksGenerated) {
    const queryImports = `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions, QueryKey } from '@tanstack/react-query';\n`;
    const axiosErrorImport = `import { AxiosError } from 'axios';\n`;
    const baseFunctionImport = `import * as API from './functions';\n`; // Import base functions from sibling functions dir
    const typeImport = `import * as ${tagImportName} from './types';\n\n`;
    hooksContent = queryImports + axiosErrorImport + baseFunctionImport + typeImport + hooksContent;

    const hooksTopBanner = createTopLevelBanner("hooks");
    hooksContent = `${hooksTopBanner}\n\n` + hooksContent;
    console.log(`  [RQ Summary] Added imports/banner. Final hooksContent length: ${hooksContent.length}`); // Log final content length
  } else if (reactQueryEnabled) {
    console.log("  [RQ Summary] React Query enabled, but no hooks were generated for this tag."); // Log if no hooks generated
  }

  // Ensure the function returns the object
  return { typesContent, functionsContent, hooksContent };
}
