import { OpenAPIV3 } from "openapi-types";
import { OperationInfo } from "./index"; // Import shared type
import {
  toTsIdentifier,
  toPascalCase,
  getPathBasedBaseName,
  createTopLevelBanner,
  createOperationGroupBanner,
} from "./helpers/generator-helpers";
import { PackageConfig, ResolvedPackageConfig, defaultConfig } from "./config";
// Corrected path: ./ instead of ../
// Import the new helper function
import { _generateFunctionFactory, _generateOperationTypes, _generateHookFactory } from "./helpers/generator-parts";

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document,
  reactQueryEnabled: boolean,
  packageConfig: ResolvedPackageConfig
): Promise<{
  typesContent: string;
  functionsContent: string;
  hooksContent: string;
  functionFactoryNames: string[];
  hookFactoryNames: string[];
  hasGeneratedTypes: boolean;
}> {
  const standardFileComment = `/* eslint-disable */\n/**\n * This file was automatically generated by sg-schema-sync.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run sg-schema-sync to regenerate this file.\n */`;

  // Create top-level banner for types file
  const typeTopBanner = createTopLevelBanner("types");
  let typesContent = `${typeTopBanner}\n\n${standardFileComment}\n`; // Ensures standard comment is present

  // Create top-level banner for functions file
  const functionTopBanner = createTopLevelBanner("functions");
  let functionsContent = `${functionTopBanner}\n\n${standardFileComment}\n\n`; // Added standard comment

  functionsContent += `// Imports for the requester mechanism\n`;
  functionsContent += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from 'sg-schema-sync/requester-types';\n`;
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  // This will be added conditionally later

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag
  const functionFactoryNames: string[] = []; // Initialize
  const hookFactoryNames: string[] = []; // Initialize

  if (packageConfig.verbose) console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  // Initialize hooksContent
  let hooksContent = "";
  let hooksGenerated = false; // Track if any hooks are added for this tag

  // --- Imports and header for hooksContent will be added AFTER the loop if hooksGenerated is true ---

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;

    const operationId = operation.operationId;

    // Apply stripPathPrefix if configured
    let processedPath = path;
    if (packageConfig.stripPathPrefix && processedPath.startsWith(packageConfig.stripPathPrefix)) {
      processedPath = processedPath.substring(packageConfig.stripPathPrefix.length);
      if (processedPath && !processedPath.startsWith("/")) {
        processedPath = "/" + processedPath;
      }
    }

    // BaseName for types (uses operationId or path)
    const baseNameForTypes = operationId ? toPascalCase(operationId) : getPathBasedBaseName(path);

    // Generate function, type, and hook base names from config templates
    const methodPascal = toPascalCase(method);
    const endpointBaseName = getPathBasedBaseName(processedPath);

    const functionName = (packageConfig.generateFunctionNames ?? defaultConfig.generateFunctionNames!)
      .replace("{method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const typeBaseNameForOperation = (packageConfig.generateTypesNames ?? defaultConfig.generateTypesNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const hookBaseName = (packageConfig.generateHooksNames ?? defaultConfig.generateHooksNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const summary = operation.summary || "No Description Provided";
    const operationGroupBanner = createOperationGroupBanner(operation.summary, method, processedPath);

    typesContent += `\n\n${operationGroupBanner}\n`; // Add banner before types for this operation

    // --- Generate Types for the current operation using the helper ---
    const {
      typesString: operationTypesString,
      requestBodyTypeName: actualRequestBodyTypeName,
      parametersTypeName: actualParametersTypeName,
      primaryResponseTypeName,
      requestBodyFailed,
      parametersTypeFailed,
      responseTypeFailed,
      primaryResponseTypeGenerated,
    } = await _generateOperationTypes(
      opInfo,
      typeBaseNameForOperation, // Use the more specific name for type generation
      tagName, // For logging inside the helper
      generatedTypeNames // Pass the set to track unique names
    );
    typesContent += operationTypesString;
    // No need to re-initialize actualRequestBodyTypeName, etc. as they are returned by the helper.

    // Determine authRequirement (remains here as it's straightforward)
    const authRequire = !!(operation.security && operation.security.length > 0);

    // --- Define variables needed by both function factory and hook generation ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];

    // --- Call the helper to generate the function factory string ---
    const currentFunctionFactoryString = _generateFunctionFactory(
      opInfo,
      functionName,
      summary,
      operationGroupBanner, // This banner is now generated before types and function factory
      tagImportName,
      processedPath,
      authRequire,
      actualRequestBodyTypeName, // From _generateOperationTypes
      actualParametersTypeName, // From _generateOperationTypes
      primaryResponseTypeName, // From _generateOperationTypes
      requestBodyFailed, // From _generateOperationTypes
      parametersTypeFailed, // From _generateOperationTypes
      responseTypeFailed, // From _generateOperationTypes
      primaryResponseTypeGenerated, // From _generateOperationTypes
      packageConfig
    );
    functionsContent += currentFunctionFactoryString;
    functionFactoryNames.push(functionName);

    // --- Generate React Query Hook (if enabled) by calling the helper ---
    if (reactQueryEnabled && packageConfig.generateHooks) {
      hooksGenerated = true; // Mark that at least one hook is attempted for this tag

      const hookFactoryName = `create${hookBaseName}Hook`; // hookBaseName is defined earlier

      const currentHookFactoryString = _generateHookFactory(
        opInfo,
        hookFactoryName,
        functionName, // This is the `correspondingFunctionFactoryName`
        summary,
        operationGroupBanner, // Pass the same banner
        tagImportName,
        sanitizedTagName, // Defined at the top of generateFilesForTag
        endpointBaseName, // Defined earlier based on processedPath
        processedPath,
        actualRequestBodyTypeName, // From _generateOperationTypes
        actualParametersTypeName, // From _generateOperationTypes
        primaryResponseTypeName, // From _generateOperationTypes
        pathParams, // Defined earlier in the loop
        packageConfig
      );

      if (currentHookFactoryString && currentHookFactoryString.trim() !== "") {
        hooksContent += currentHookFactoryString;
        hookFactoryNames.push(hookFactoryName);
      } else {
        if (packageConfig.verbose) {
          console.log(`    [${tagName}] _generateHookFactory returned empty for ${hookFactoryName}, skipping.`);
        }
      }
    }
  } // End loop through operations

  // Conditionally add import for './types' to functionsContent
  if (generatedTypeNames.size > 0) {
    // The main `functionsContent` already has the function factory strings accumulated from the loop.
    // We just need to ensure the imports are at the top.
    // Let's rebuild functionsContent to ensure correct order of imports and then content.
    // The current `functionsContent` starts with banners and initial `sg-schema-sync/requester-types` import,
    // then `tagImportName` types import, then all the actual function factories.
    // The helpers _generateFunctionFactory and _generateHookFactory add their own operationGroupBanners.
    // The `functionsContent` at this point should look like:
    // Banner + Standard Comment
    // import { SGSyncRequester... } from 'sg-schema-sync/requester-types';
    // import * as ${tagImportName} from './types';
    // OperationGroupBanner for op1
    // export function createOp1 ...
    // OperationGroupBanner for op2
    // export function createOp2 ...
    // This structure is already correct because `functionsContent` is built sequentially:
    // 1. Top banner + standard comment.
    // 2. Requester types import.
    // 3. `* as ${tagImportName} from './types'` import (this was added early).
    // 4. Then, in the loop, each call to _generateFunctionFactory returns a string starting with
    //    an operationGroupBanner, which is then appended.
    // So, no specific rebuilding of functionsContent is needed here if the `import * as ${tagImportName}`
    // was correctly added *before* the loop started appending function factory strings.
    // Reviewing the top of the file for `functionsContent` initial build:
    // functionsContent += `import * as ${tagImportName} from './types';\\n\\n`; IS added before the loop.
    // Therefore, this entire if block might be redundant if the only goal was to add this import,
    // as it's already done.
    // However, the original code had a more complex reconstruction here, let's simplify but ensure imports are correctly ordered if there was a subtle reason.
    // The current structure of `functionsContent` is already:
    // 1. functionTopBanner + standardFileComment
    // 2. SGSyncRequester import
    // 3. `tagImportName` import (e.g., `import * as UsersTypes from './types';`)
    // 4. Concatenated strings from `_generateFunctionFactory` (each starting with an op banner)
    // This order is correct. The `if (generatedTypeNames.size > 0)` was likely a guard
    // for the `import * as ${tagImportName} from './types';` line.
    // Since that import is now added unconditionally earlier:
    // `functionsContent += \`import * as ${tagImportName} from './types';\\n\\n\`;` (line 40 approx)
    // this whole if block for rebuilding `functionsContent` is indeed no longer necessary.
    // The check `generatedTypeNames.size > 0` is still useful for the return value of `generateFilesForTag`
    // (`hasGeneratedTypes`), but not for rebuilding `functionsContent` here.
  }

  // --- Add Imports and Header to hooksContent if needed ---
  if (reactQueryEnabled && hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    let finalHooksImports = `// Imports for the requester mechanism and TanStack Query\n`;
    finalHooksImports += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from 'sg-schema-sync/requester-types';\n`;
    if (generatedTypeNames.size > 0) {
      // Conditional import for types
      finalHooksImports += `import * as ${tagImportName} from './types';\n`;
    }

    const tanstackImports = ["QueryKey", "useMutation", "UseMutationOptions", "useQuery", "UseQueryOptions"].sort();
    finalHooksImports += `import {\n  ${tanstackImports.join(",\n  ")}\n} from '@tanstack/react-query';\n`;

    if (functionFactoryNames.length > 0) {
      let factoryImportStatements = "  " + functionFactoryNames.join(",\n  ");
      finalHooksImports += `import {\n${factoryImportStatements}\n} from './functions';\n`;
    }
    finalHooksImports += `\n`; // Add a newline after imports

    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n${finalHooksImports}${hooksContent}`;
  } else if (reactQueryEnabled && !hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n// React Query is enabled, but no hooks were generated for this tag.\n`;
    if (packageConfig.verbose)
      console.log(`  [RQ Summary] React Query enabled, but no hook factories were generated for tag: ${tagName}.`);
  }
  // If !reactQueryEnabled, hooksContent remains "" which is fine.

  return {
    typesContent,
    functionsContent,
    hooksContent,
    functionFactoryNames,
    hookFactoryNames,
    hasGeneratedTypes: generatedTypeNames.size > 0,
  };
}
