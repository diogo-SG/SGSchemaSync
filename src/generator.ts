import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now

// Helper to generate a TS identifier (e.g., for function names, types)
function toTsIdentifier(str: string): string {
  if (!str) return "_"; // Handle empty or null strings
  // Remove leading/trailing non-alphanumeric, replace separators with underscores
  const cleaned = str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "").replace(/[^a-zA-Z0-9_]+/g, "_");
  // Ensure it starts with a letter or underscore if the first char was numeric or if empty after cleaning
  if (!cleaned || /^[0-9]/.test(cleaned)) {
    return `_${cleaned}`;
  }
  return cleaned;
}

// Helper to generate a PascalCase type name
function toPascalCase(str: string): string {
  if (!str) return "Type"; // Handle empty or null strings
  // Correctly handle splitting and mapping
  return str
    .split(/[^a-zA-Z0-9]/)
    .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : ""))
    .join("");
}

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document
): Promise<{ typesContent: string; functionsContent: string }> {
  let typesContent = `// Types for ${tagName}\n\n/* eslint-disable */\n/**\n * This file was automatically generated by api-client-generator.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run api-client-generator to regenerate this file.\n */\n`;
  let functionsContent = `// API Functions for ${tagName}\n\n`;
  functionsContent += `import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\n`;
  // Generate a safe identifier for the tag import
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  functionsContent += `import * as ${tagImportName} from '../types/${sanitizedTagName}';\n\n// TODO: Add function implementations here\n`; // Placeholder for functions

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag

  console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;
    // Create a base name for types, preferring operationId
    const baseName = operationId
      ? toPascalCase(operationId)
      : toPascalCase(`${method}_${path.replace(/[^a-zA-Z0-9_]/g, "_")}`);
    const functionName = toTsIdentifier(operationId || baseName); // Use operationId for func name if possible

    let actualRequestBodyTypeName: string | null = null;
    let requestBodyFailed = false; // Flag for function comment
    let actualParametersTypeName: string | null = null;
    let parametersTypeFailed = false; // Flag for function comment
    let primaryResponseTypeName: string | null = null;
    let primaryResponseTypeGenerated = false;
    let responseTypeFailed = false; // Flag for function comment

    // --- Generate Request Body Type --- (and store name)
    if (operation.requestBody && "content" in operation.requestBody) {
      const requestBodySchema = operation.requestBody.content?.["application/json"]?.schema;
      if (requestBodySchema) {
        const typeName = `${baseName}RequestBody`;
        actualRequestBodyTypeName = typeName; // Store for function signature
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(requestBodySchema as JSONSchema, typeName, { bannerComment: "" });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate request body type ${typeName}: ${errMsg}`);
            // Add comment to types file
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualRequestBodyTypeName = null;
            requestBodyFailed = true; // Set flag
          }
        }
      }
    }

    // --- Generate Response Types --- (and store name)
    for (const statusCode in operation.responses) {
      if (statusCode.startsWith("2")) {
        const response = operation.responses[statusCode] as OpenAPIV3.ResponseObject;
        // Define primarySuccessCode *before* any logic that uses it in this block
        const primarySuccessCode = method === "post" ? "201" : "200";
        const isPrimary = statusCode === primarySuccessCode;

        // Focus on primary success code first to determine function return type
        if (isPrimary) {
          if (response && "content" in response && response.content?.["application/json"]?.schema) {
            const responseSchema = response.content["application/json"].schema;
            const typeName = `${baseName}Response${isPrimary ? "" : statusCode}`;
            primaryResponseTypeName = typeName; // Store intended name regardless of generation success initially

            if (!generatedTypeNames.has(typeName)) {
              try {
                const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
                typesContent += `\n${tsType}\n`;
                generatedTypeNames.add(typeName);
                primaryResponseTypeGenerated = true; // Mark as successful ONLY if compile works
              } catch (err: any) {
                const errMsg = err.message;
                console.warn(
                  `    [${tagName}] Failed to generate response type ${typeName} (status ${statusCode}): ${errMsg}`
                );
                // Add comment to types file
                typesContent += `\n// ⚠️ Type generation failed for ${typeName} (status ${statusCode}): ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
                if (isPrimary) responseTypeFailed = true; // Set flag only if primary failed
              }
            } else {
              primaryResponseTypeGenerated = true; // Already generated successfully
            }
          } else if (isPrimary && !response?.content) {
            primaryResponseTypeName = "void";
            primaryResponseTypeGenerated = true;
          } else if (isPrimary) {
            console.warn(
              `    [${tagName}] No content schema for primary success ${primarySuccessCode} for ${functionName}.`
            );
            responseTypeFailed = true; // Mark as failed for function comment
          }
        } else {
          // Handle other 2xx codes (generate type but don't affect primary flags)
          if (response && "content" in response && response.content?.["application/json"]?.schema) {
            const responseSchema = response.content["application/json"].schema;
            const typeName = `${baseName}Response${statusCode}`; // Keep status code for non-primary
            if (!generatedTypeNames.has(typeName)) {
              try {
                const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
                typesContent += `\n${tsType}\n`;
                generatedTypeNames.add(typeName);
              } catch (err: any) {
                console.warn(
                  `    [${tagName}] Failed to generate response type ${typeName} for status ${statusCode}: ${err.message}`
                );
              }
            }
          }
        }
      }
    }

    // --- Generate Parameters Type --- (and store name)
    const queryParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "query"
      ) as OpenAPIV3.ParameterObject[]) || [];
    if (queryParams && queryParams.length > 0) {
      const paramsSchema: JSONSchema = { type: "object", properties: {}, required: [] };
      queryParams.forEach((p) => {
        if (paramsSchema.properties) {
          paramsSchema.properties[p.name] = p.schema || { type: "string" };
          if (p.required) {
            if (!Array.isArray(paramsSchema.required)) {
              paramsSchema.required = [];
            }
            paramsSchema.required.push(p.name);
          }
        }
      });

      if (Object.keys(paramsSchema.properties || {}).length > 0) {
        const typeName = `${baseName}Parameters`;
        actualParametersTypeName = typeName; // Store for function signature
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(paramsSchema, typeName, { bannerComment: "", additionalProperties: false });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate parameters type ${typeName}: ${errMsg}`);
            // Add comment to types file
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualParametersTypeName = null;
            parametersTypeFailed = true; // Set flag
          }
        }
      }
    }

    // --- Assemble Function ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];
    const funcParamsList: string[] = [];

    // Path parameters first (required)
    pathParams.forEach((p) => {
      funcParamsList.push(`${toTsIdentifier(p.name)}: string`); // Basic typing for path params
    });

    // Request Body parameter
    if (actualRequestBodyTypeName) {
      funcParamsList.push(`data: ${tagImportName}.${actualRequestBodyTypeName}`);
    }

    // Query Parameters parameter
    if (actualParametersTypeName) {
      // Check if any query param is required within the generated type (optional step for accuracy)
      // For simplicity now, we assume the whole params object is optional if generated
      funcParamsList.push(`params?: ${tagImportName}.${actualParametersTypeName}`);
    }

    // Standard Axios config parameter
    funcParamsList.push(`config?: AxiosRequestConfig`);

    const funcParamsString = funcParamsList.join(",\n  ");

    const urlPath = path.replace(/{([^}]+)}/g, (match, paramName) => `$\{${toTsIdentifier(paramName)}\}`);

    // Determine final response type string for the Promise
    let finalResponseTypeNameForSig: string;
    if (primaryResponseTypeGenerated) {
      if (primaryResponseTypeName === "void") {
        finalResponseTypeNameForSig = "void";
      } else if (primaryResponseTypeName) {
        // IMPORTANT: Only use the specific type if generation succeeded
        finalResponseTypeNameForSig = `${tagImportName}.${primaryResponseTypeName}`;
      } else {
        finalResponseTypeNameForSig = "any"; // Fallback if name is null despite flag being true (edge case)
      }
    } else {
      finalResponseTypeNameForSig = "any"; // Fallback if generation failed or no suitable schema
    }

    // Build function comment string if needed
    let functionComment = "";
    if (requestBodyFailed) {
      functionComment += `// ⚠️ WARNING: Request Body type generation failed, using 'any' for data parameter if applicable. Check OpenAPI spec.\n`;
    }
    if (parametersTypeFailed) {
      functionComment += `// ⚠️ WARNING: Parameters type generation failed, using 'any' for params parameter if applicable. Check OpenAPI spec.\n`;
    }
    if (responseTypeFailed || (!primaryResponseTypeGenerated && primaryResponseTypeName !== "void")) {
      functionComment += `// ⚠️ WARNING: Response type generation failed or schema missing, using '${finalResponseTypeNameForSig}' as fallback. Check OpenAPI spec.\n`;
    }

    // Build function string
    let functionString = "";
    if (functionComment) {
      functionString += `\n${functionComment}`; // Add the warning comment before JSDoc
    }
    functionString += `/**\n * ${operation.summary || "No summary provided"}\n`;
    if (operation.description) {
      functionString += ` * ${operation.description.replace(/\n/g, "\n * ")}\n`;
    }
    functionString += ` */\n`;
    functionString += `export async function ${functionName}(\n  ${funcParamsString}\n`;
    functionString += `): Promise<AxiosResponse<${finalResponseTypeNameForSig}>> {\n`;
    functionString += `  const url = \`${urlPath}\`;`;
    functionString += `  const axiosConfig: AxiosRequestConfig = {\n`;
    functionString += `    method: '${method}',`;
    functionString += `    url,`;
    if (actualParametersTypeName) {
      functionString += `    params,`;
    }
    if (actualRequestBodyTypeName) {
      functionString += `    data,`;
    }
    functionString += `    ...config,`;
    functionString += `  };`;
    functionString += `  return axios(axiosConfig);`;
    functionString += `}\n`; // End of function definition

    functionsContent += functionString; // Append the complete function string
  } // End loop through operations

  // Ensure the function returns the object
  return { typesContent, functionsContent };
}
