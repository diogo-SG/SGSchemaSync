import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now
import {
  toTsIdentifier,
  toPascalCase,
  getPathBasedBaseName,
  createTopLevelBanner,
  createOperationGroupBanner,
} from "./helpers/generator-helpers";
import { PackageConfig, defaultConfig } from "./config";
// NEW: Import requester types
import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from "./requester-types";
// Corrected path: ./ instead of ../

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document,
  reactQueryEnabled: boolean,
  packageConfig: Partial<PackageConfig>
): Promise<{
  typesContent: string;
  functionsContent: string;
  hooksContent: string;
  functionFactoryNames: string[];
  hookFactoryNames: string[];
}> {
  const standardFileComment = `/* eslint-disable */\n/**\n * This file was automatically generated by sg-schema-sync.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run sg-schema-sync to regenerate this file.\n */`;

  // Create top-level banner for types file
  const typeTopBanner = createTopLevelBanner("types");
  let typesContent = `${typeTopBanner}\n\n${standardFileComment}\n`; // Ensures standard comment is present

  // Create top-level banner for functions file
  const functionTopBanner = createTopLevelBanner("functions");
  let functionsContent = `${functionTopBanner}\n\n${standardFileComment}\n\n`; // Added standard comment

  functionsContent += `// Imports for the requester mechanism\n`;
  functionsContent += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from 'sg-schema-sync/requester-types';\n`;
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  // This will be added conditionally later

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag
  const functionFactoryNames: string[] = []; // Initialize
  const hookFactoryNames: string[] = []; // Initialize

  console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  // Initialize hooksContent
  let hooksContent = "";
  let hooksGenerated = false; // Track if any hooks are added for this tag

  // --- Imports and header for hooksContent will be added AFTER the loop if hooksGenerated is true ---

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;

    // Apply stripPathPrefix if configured
    let processedPath = path;
    if (packageConfig.stripPathPrefix && processedPath.startsWith(packageConfig.stripPathPrefix)) {
      processedPath = processedPath.substring(packageConfig.stripPathPrefix.length);
      // Ensure the path still starts with a / if it's not empty after stripping
      if (processedPath && !processedPath.startsWith("/")) {
        processedPath = "/" + processedPath;
      }
    }

    // BaseName for types (uses operationId or path)
    // For types, we still use the original path for getPathBasedBaseName to maintain original naming if stripPathPrefix is only for URL construction
    const baseNameForTypes = operationId ? toPascalCase(operationId) : getPathBasedBaseName(path);

    // --- Generate function name using new convention ---
    // Use processedPath for endpointBaseName if it affects naming conventions for functions/hooks
    const endpointBaseName = getPathBasedBaseName(processedPath);
    const methodUpper = method.toUpperCase();
    const methodPascal = toPascalCase(method);

    // Generate names using templates from config
    const functionName = (packageConfig.generateFunctionNames ?? defaultConfig.generateFunctionNames!)
      .replace("{method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const typeBaseName = (packageConfig.generateTypesNames ?? defaultConfig.generateTypesNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const hookBaseName = (packageConfig.generateHooksNames ?? defaultConfig.generateHooksNames!)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    // Add Operation Banners to Types File (using operation summary)
    const summary = operation.summary || "No Description Provided";

    // Create banner for the operation group, use processedPath for display
    const operationGroupBanner = createOperationGroupBanner(operation.summary, method, processedPath);

    typesContent += `\n\n${operationGroupBanner}\n`;

    // Flags and type name variables initialization
    let actualRequestBodyTypeName: string | null = null;
    let requestBodyFailed = false;
    let actualParametersTypeName: string | null = null;
    let parametersTypeFailed = false;
    let primaryResponseTypeName: string | null = null;
    let primaryResponseTypeGenerated = false;
    let responseTypeFailed = false;

    // Determine authRequirement
    const authRequire = !!(operation.security && operation.security.length > 0);
    // console.log(`    [Auth] Operation ${method.toUpperCase()} ${path} requires auth: ${authRequire}`);

    // --- Generate Request Body Type ---
    if (operation.requestBody && "content" in operation.requestBody) {
      const requestBodySchema = operation.requestBody.content?.["application/json"]?.schema;
      if (requestBodySchema) {
        const typeName = `${typeBaseName}_Request`;
        actualRequestBodyTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(requestBodySchema as JSONSchema, typeName, { bannerComment: "" });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate request body type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualRequestBodyTypeName = null;
            requestBodyFailed = true;
          }
        }
      }
    }

    // --- Generate Response Types ---
    for (const statusCode in operation.responses) {
      if (statusCode.startsWith("2")) {
        const response = operation.responses[statusCode] as OpenAPIV3.ResponseObject;
        const primarySuccessCode = method === "post" ? "201" : "200";
        const isPrimary = statusCode === primarySuccessCode;
        if (response && "content" in response && response.content?.["application/json"]?.schema) {
          const responseSchema = response.content["application/json"].schema;
          const typeName = `${typeBaseName}_Response${isPrimary ? "" : `_${statusCode}`}`;
          if (isPrimary) primaryResponseTypeName = typeName;
          if (!generatedTypeNames.has(typeName)) {
            try {
              const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
              typesContent += `\n${tsType}\n`;
              generatedTypeNames.add(typeName);
              if (isPrimary) primaryResponseTypeGenerated = true;
            } catch (err: any) {
              const errMsg = err.message;
              console.warn(
                `    [${tagName}] Failed to generate response type ${typeName} (status ${statusCode}): ${errMsg}`
              );
              typesContent += `\n// ⚠️ Type generation failed for ${typeName} (status ${statusCode}): ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
              if (isPrimary) responseTypeFailed = true;
            }
          } else {
            if (isPrimary) primaryResponseTypeGenerated = true;
          }
        } else if (isPrimary && !response?.content) {
          primaryResponseTypeName = "void";
          primaryResponseTypeGenerated = true;
        } else if (isPrimary) {
          console.warn(
            `    [${tagName}] No content schema for primary success ${primarySuccessCode} for ${functionName}.`
          );
          responseTypeFailed = true;
        }
      }
    }

    // --- Generate Parameters Type ---
    const queryParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "query"
      ) as OpenAPIV3.ParameterObject[]) || [];
    if (queryParams && queryParams.length > 0) {
      const paramsSchema: JSONSchema = { type: "object", properties: {}, required: [] };
      queryParams.forEach((p) => {
        if (paramsSchema.properties) {
          paramsSchema.properties[p.name] = p.schema || { type: "string" };
          if (p.required) {
            if (!Array.isArray(paramsSchema.required)) {
              paramsSchema.required = [];
            }
            paramsSchema.required.push(p.name);
          }
        }
      });
      if (Object.keys(paramsSchema.properties || {}).length > 0) {
        const typeName = `${typeBaseName}_Parameters`;
        actualParametersTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(paramsSchema, typeName, { bannerComment: "", additionalProperties: false });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate parameters type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualParametersTypeName = null;
            parametersTypeFailed = true;
          }
        }
      }
    }

    // --- Assemble Function Factory ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];

    const factoryInnerFuncParamsList: string[] = [];
    pathParams.forEach((p) => {
      factoryInnerFuncParamsList.push(`${toTsIdentifier(p.name)}: string`);
    });

    let requestBodyTypeForFunc: string | null = null;
    if (actualRequestBodyTypeName) {
      requestBodyTypeForFunc = `${tagImportName}.${actualRequestBodyTypeName}`;
      factoryInnerFuncParamsList.push(`data: ${requestBodyTypeForFunc}`);
    }

    let queryParamsTypeForFunc: string | null = null;
    if (actualParametersTypeName) {
      queryParamsTypeForFunc = `${tagImportName}.${actualParametersTypeName}`;
      factoryInnerFuncParamsList.push(`params?: ${queryParamsTypeForFunc}`);
    }

    // Add callSpecificOptions to the inner function
    // Omitting fields that are set by the factory itself
    const callSpecificOptionsType = `Partial<Omit<SGSyncRequesterOptions, 'method' | 'url' | 'authRequire'${requestBodyTypeForFunc ? " | 'data'" : ""}${queryParamsTypeForFunc ? " | 'params'" : ""}>>`;
    factoryInnerFuncParamsList.push(`callSpecificOptions?: ${callSpecificOptionsType}`);

    const factoryInnerFuncParamsString = factoryInnerFuncParamsList.join(",\n    ");
    // Use processedPath for generating the runtime urlPath
    const urlPath = processedPath.replace(/{([^}]+)}/g, (match, paramNameInPath) => {
      const sanitizedParamName = toTsIdentifier(paramNameInPath);
      return `\${${sanitizedParamName}}`; // Ensure this correctly interpolates the variable
    });

    let finalResponseTypeNameForSig: string;
    let responseTypeForSGSyncResponse: string;

    if (primaryResponseTypeGenerated) {
      if (primaryResponseTypeName === "void") {
        finalResponseTypeNameForSig = "void";
        responseTypeForSGSyncResponse = "void";
      } else if (primaryResponseTypeName) {
        finalResponseTypeNameForSig = `${tagImportName}.${primaryResponseTypeName}`;
        responseTypeForSGSyncResponse = finalResponseTypeNameForSig;
      } else {
        finalResponseTypeNameForSig = "any";
        responseTypeForSGSyncResponse = "any";
      }
    } else {
      finalResponseTypeNameForSig = "any";
      responseTypeForSGSyncResponse = "any";
    }

    let functionComment = "";
    if (requestBodyFailed) {
      functionComment += `// ⚠️ WARNING: Request Body type generation failed. 'data' parameter type may be incorrect.\n`;
    }
    if (parametersTypeFailed) {
      functionComment += `// ⚠️ WARNING: Parameters type generation failed. 'params' parameter type may be incorrect.\n`;
    }
    if (responseTypeFailed || (!primaryResponseTypeGenerated && primaryResponseTypeName !== "void")) {
      functionComment += `// ⚠️ WARNING: Response type generation failed or schema missing. Expected response type is '${responseTypeForSGSyncResponse}'.\n`;
    }

    let functionString = "";
    if (functionComment) {
      functionString += `\n${functionComment}`;
    }
    functionString += `\n\n${operationGroupBanner}\n`;
    functionString += `/**\n * Factory for a function to call ${summary}\n`;
    if (operation.description && operation.description !== summary) {
      functionString += ` * ${operation.description.replace(/\n/g, "\n * ")}\n`;
    }
    functionString += ` * @param requester The SGSyncRequester instance to use for making the actual HTTP request.\n`;
    functionString += ` */\n`;
    // Note: baseFunctionName is what the user will call, functionFactoryName is the exported factory.
    functionString += `export const ${functionName} = (requester: SGSyncRequester) => {\n`;
    functionString += `  /**\n   * ${summary}\n   */\n`;
    functionString += `  return async (\n    ${factoryInnerFuncParamsString}\n  ): Promise<SGSyncResponse<${responseTypeForSGSyncResponse}>> => {\n`;
    functionString += `    const path = \`${urlPath}\`;\n`;
    functionString += `    const options: SGSyncRequesterOptions = {\n`;
    functionString += `      method: '${method}',\n`;
    functionString += `      url: path,\n`;
    functionString += `      authRequire: ${authRequire},`;
    if (queryParamsTypeForFunc) {
      functionString += `
      params: params,`;
    }
    if (requestBodyTypeForFunc) {
      functionString += `
      data: data,`;
    }
    functionString += `
      ...(callSpecificOptions || {}),
    };\n`;
    functionString += `    return requester<${responseTypeForSGSyncResponse}>(options);\n`;
    functionString += `  };\n`;
    functionString += `};\n`;

    functionsContent += functionString;
    functionFactoryNames.push(functionName);

    // --- Generate React Query Hook (if enabled) ---
    if (reactQueryEnabled && packageConfig.generateHooks) {
      hooksGenerated = true; // Mark that at least one hook is generated for this tag

      const hookFactoryName = `create${hookBaseName}Hook`;
      hookFactoryNames.push(hookFactoryName);

      // Determine queryKey structure - use processedPath for endpointBaseName which is used in queryKeyParts
      let queryKeyParts = [`"${sanitizedTagName}"`, `"${endpointBaseName}"`]; // endpointBaseName is now from processedPath
      pathParams.forEach((p) => queryKeyParts.push(toTsIdentifier(p.name)));

      // Arguments for the function created by the function factory (these are the actual values passed, not type defs)
      const factoryInnerFuncArgsForHookCall = factoryInnerFuncParamsList.map((param) => {
        return param.split(":")[0].replace("?", "").trim();
      });

      let hookComment = `/**\n`;
      hookComment += ` * Factory for creating a TanStack Query hook for: ${summary}\n`;
      hookComment += ` * Method: ${method.toUpperCase()}, Path: ${processedPath}\n`; // Use processedPath in comments
      if (operation.description) {
        hookComment += ` * Description: ${operation.description.replace(/\n/g, "\n *   ")}\n`;
      }
      hookComment += ` * @param requester The SGSyncRequester instance to use for making the underlying API call.\n`;
      hookComment += ` * @returns A TanStack Query hook.\n`;
      hookComment += ` */`;

      hooksContent += `\n${hookComment}\n`;
      hooksContent += `export function ${hookFactoryName}(\n  requester: SGSyncRequester\n) {\n`;

      hooksContent += `  const ${functionName}Instance = ${functionName}(requester);\n`;

      if (method === "get") {
        const hookSignatureParamsList: string[] = [];
        pathParams.forEach((p) => hookSignatureParamsList.push(`${toTsIdentifier(p.name)}: string`));
        if (queryParamsTypeForFunc) {
          queryKeyParts.push("queryParams");
          hookSignatureParamsList.push(`queryParams?: ${queryParamsTypeForFunc}`);
        }
        hookSignatureParamsList.push(`callSpecificOptions?: ${callSpecificOptionsType}`);

        const queryOptionsType = `Omit<UseQueryOptions<${finalResponseTypeNameForSig}, Error, ${finalResponseTypeNameForSig}, QueryKey>, 'queryKey' | 'queryFn'>`;
        hooksContent += `  return function ${hookBaseName}(\n`;
        hooksContent += `    ${hookSignatureParamsList.join(",\n    ")}${hookSignatureParamsList.length > 0 ? "," : ""}\n`;
        hooksContent += `    queryOptions?: ${queryOptionsType}\n`;
        hooksContent += `  ) {\n`;
        hooksContent += `    const queryKeyInternal = [${queryKeyParts.join(", ")}] as QueryKey;\n`;

        // Construct the argument string for the function call within queryFn
        const queryFnCallArgsString = factoryInnerFuncArgsForHookCall
          .map((arg) => (arg === "params" ? "queryParams" : arg))
          .join(", ");

        hooksContent += `    return useQuery<${finalResponseTypeNameForSig}, Error, ${finalResponseTypeNameForSig}, QueryKey>({\n`;
        hooksContent += `      queryKey: queryKeyInternal,\n`;
        hooksContent += `      queryFn: async () => {\n`;
        hooksContent += `        const response = await ${functionName}Instance(${queryFnCallArgsString});\n`;
        hooksContent += `        return response.data; // Assumes response structure { data: T }\n`;
        hooksContent += `      },\n`;
        hooksContent += `      ...(queryOptions || {}),\n`;
        hooksContent += `    });\n`;
      } else {
        // useMutation
        let mutationVariablesType = "void";
        // Determine mutationVariablesType based on what functionNameInstance expects.
        // This mirrors the logic in factoryInnerFuncParamsList for functionFactoryName
        const mutationFuncExpectedParams = factoryInnerFuncParamsList;
        if (mutationFuncExpectedParams.length === 1) {
          const singleParamType = mutationFuncExpectedParams[0].split(":")[1].trim();
          mutationVariablesType = singleParamType;
        } else if (mutationFuncExpectedParams.length > 1) {
          // Create an object type for variables
          mutationVariablesType = `{ ${mutationFuncExpectedParams.map((p) => p.replace("?:", ":")).join("; ")} }`;
        }

        const mutationOptionsType = `Omit<UseMutationOptions<${finalResponseTypeNameForSig}, Error, ${mutationVariablesType}>, 'mutationFn'>`;
        hooksContent += `  return function ${hookBaseName}(\n`;
        hooksContent += `    mutationOptions?: ${mutationOptionsType}\n`;
        hooksContent += `  ) {\n`;
        hooksContent += `    return useMutation<${finalResponseTypeNameForSig}, Error, ${mutationVariablesType}>({\n`;
        hooksContent += `      mutationFn: async (${mutationVariablesType === "void" ? "" : "variables"}) => {\n`;

        let callArgs = "";
        if (mutationVariablesType !== "void") {
          if (mutationFuncExpectedParams.length === 1) {
            callArgs = "variables";
          } else if (mutationFuncExpectedParams.length > 1) {
            callArgs = factoryInnerFuncArgsForHookCall.map((argName) => `variables.${argName}`).join(", ");
          }
        }

        hooksContent += `        const response = await ${functionName}Instance(${callArgs});\n`;
        hooksContent += `        return response.data; // Assumes response structure { data: T }\n`;
        hooksContent += `      },\n`;
        hooksContent += `      ...(mutationOptions || {}),\n`;
        hooksContent += `    });\n`;
        hooksContent += `  };\n`;
      }
      hooksContent += `}\n`;
    }
  } // End loop through operations

  // Conditionally add import for './types' to functionsContent
  if (generatedTypeNames.size > 0) {
    // Insert it after the requester import but before the first function definition.
    // A simple way is to prepend it to the collected function strings if we know there's other content.
    // Or, more robustly, rebuild functionsContent if we need precise placement.
    // For now, let's find a marker or prepend to the accumulated functions string part.
    // Let's adjust how functionsContent is built to make this cleaner.
    // We'll collect all function strings and then prepend imports.

    let allFunctionStrings = "";
    for (const funcName of functionFactoryNames) {
      // This assumes functionString was the last one generated and corresponds to funcName.
      // This is a bit of a simplification; ideally, we'd store all functionStrings.
      // For this refactor, we'll assume 'functionsContent' holds all generated function strings
      // after the initial banner and requester import.
      // This part needs refinement if we want to re-use 'functionString'
    }
    // The actual function strings are already in 'functionsContent'.
    // We need to insert the import.
    // A simpler approach: construct the core content, then add imports at the top.

    // Let's rebuild functionsContent to ensure correct order
    let finalFunctionsContent = `${functionTopBanner}\n\n${standardFileComment}\n\n`;
    finalFunctionsContent += `// Imports for the requester mechanism\n`;
    finalFunctionsContent += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from 'sg-schema-sync/requester-types';\n`;
    finalFunctionsContent += `import * as ${tagImportName} from './types';\n\n`; // Added conditionally
    finalFunctionsContent += functionsContent.substring(
      functionsContent.indexOf("/*---") // Assuming operation group banners start like this
    ); // Append the actual function definitions
    functionsContent = finalFunctionsContent;
  }

  // --- Add Imports and Header to hooksContent if needed ---
  if (reactQueryEnabled && hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    let finalHooksImports = `// Imports for the requester mechanism and TanStack Query\n`;
    finalHooksImports += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from 'sg-schema-sync/requester-types';\n`;
    if (generatedTypeNames.size > 0) {
      // Conditional import for types
      finalHooksImports += `import * as ${tagImportName} from './types';\n`;
    }

    const tanstackImports = ["QueryKey", "useMutation", "UseMutationOptions", "useQuery", "UseQueryOptions"].sort();
    finalHooksImports += `import {\n  ${tanstackImports.join(",\n  ")}\n} from '@tanstack/react-query';\n`;

    if (functionFactoryNames.length > 0) {
      let factoryImportStatements = "  " + functionFactoryNames.join(",\n  ");
      finalHooksImports += `import {\n${factoryImportStatements}\n} from './functions';\n`;
    }
    finalHooksImports += `\n`; // Add a newline after imports

    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n${finalHooksImports}${hooksContent}`;
  } else if (reactQueryEnabled && !hooksGenerated) {
    const hookTopBanner = createTopLevelBanner("hooks");
    hooksContent = `${hookTopBanner}\n\n${standardFileComment}\n\n// React Query is enabled, but no hooks were generated for this tag.\n`;
    console.log(`  [RQ Summary] React Query enabled, but no hook factories were generated for tag: ${tagName}.`);
  }
  // If !reactQueryEnabled, hooksContent remains "" which is fine.

  return { typesContent, functionsContent, hooksContent, functionFactoryNames, hookFactoryNames };
}
