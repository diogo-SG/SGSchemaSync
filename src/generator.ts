import { OpenAPIV3 } from "openapi-types";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { OperationInfo } from "./index"; // Import shared type
import { OpenAPISpec } from "./parser";
// import { format } from 'prettier'; // Removing prettier for now
import {
  toTsIdentifier,
  toPascalCase,
  getPathBasedBaseName,
  createTopLevelBanner,
  createOperationGroupBanner,
} from "./helpers/generator-helpers";
import { PackageConfig, defaultPackageConfig } from "./config";
// NEW: Import requester types
import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from "./requester-types";
// Corrected path: ./ instead of ../

export async function generateFilesForTag(
  tagName: string,
  operations: OperationInfo[],
  spec: OpenAPIV3.Document,
  reactQueryEnabled: boolean,
  packageConfig: Partial<PackageConfig>
): Promise<{
  typesContent: string;
  functionsContent: string;
  hooksContent: string;
  functionFactoryNames: string[];
  hookFactoryNames: string[];
}> {
  // Create top-level banner for types file
  const typeTopBanner = createTopLevelBanner("types");
  let typesContent = `${typeTopBanner}\n\n/* eslint-disable */\n/**\n * This file was automatically generated by sg-schema-sync.\n * DO NOT MODIFY IT BY HAND. Instead, modify the source OpenAPI file,\n * and run sg-schema-sync to regenerate this file.\n */\n`;

  // Create top-level banner for functions file
  const functionTopBanner = createTopLevelBanner("functions");
  let functionsContent = `${functionTopBanner}\n\n`;

  functionsContent += `// Imports for the requester mechanism\n`;
  functionsContent += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from './requester-types';\n`;
  const tagImportName = toTsIdentifier(tagName) + "Types";
  // Use the sanitized tag name for the file path
  const sanitizedTagName = tagName.toLowerCase().replace(/\s+|\//g, "-");
  functionsContent += `import * as ${tagImportName} from './types';\n\n`;

  const generatedTypeNames = new Set<string>(); // Track generated types for this tag
  const functionFactoryNames: string[] = []; // Initialize
  const hookFactoryNames: string[] = []; // Initialize

  console.log(`  Processing ${operations.length} operations for tag: ${tagName}`);

  // Initialize hooksContent
  let hooksContent = "";
  let hooksGenerated = false; // Track if any hooks are added for this tag

  for (const opInfo of operations) {
    const { operation, path, method } = opInfo;
    const operationId = operation.operationId;

    // BaseName for types (uses operationId or path)
    const baseNameForTypes = operationId ? toPascalCase(operationId) : getPathBasedBaseName(path);

    // --- Generate function name using new convention ---
    const endpointBaseName = getPathBasedBaseName(path);
    const methodUpper = method.toUpperCase();
    const methodPascal = toPascalCase(method);

    // Generate names using templates from config
    const functionName = (packageConfig.generateFunctionNames ?? defaultPackageConfig.generateFunctionNames)
      .replace("{method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const typeBaseName = (packageConfig.generateTypesNames ?? defaultPackageConfig.generateTypesNames)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    const hookBaseName = (packageConfig.generateHooksNames ?? defaultPackageConfig.generateHooksNames)
      .replace("{Method}", methodPascal)
      .replace("{Endpoint}", endpointBaseName);

    // Add Operation Banners to Types File (using operation summary)
    const summary = operation.summary || "No Description Provided";

    // Create banner for the operation group
    const operationGroupBanner = createOperationGroupBanner(operation.summary, method, path);

    typesContent += `\n\n${operationGroupBanner}\n`;

    // Flags and type name variables initialization
    let actualRequestBodyTypeName: string | null = null;
    let requestBodyFailed = false;
    let actualParametersTypeName: string | null = null;
    let parametersTypeFailed = false;
    let primaryResponseTypeName: string | null = null;
    let primaryResponseTypeGenerated = false;
    let responseTypeFailed = false;

    // Determine authRequirement
    const authRequire = !!(operation.security && operation.security.length > 0);
    // console.log(`    [Auth] Operation ${method.toUpperCase()} ${path} requires auth: ${authRequire}`);

    // --- Generate Request Body Type ---
    if (operation.requestBody && "content" in operation.requestBody) {
      const requestBodySchema = operation.requestBody.content?.["application/json"]?.schema;
      if (requestBodySchema) {
        const typeName = `${typeBaseName}_Request`;
        actualRequestBodyTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(requestBodySchema as JSONSchema, typeName, { bannerComment: "" });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate request body type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualRequestBodyTypeName = null;
            requestBodyFailed = true;
          }
        }
      }
    }

    // --- Generate Response Types ---
    for (const statusCode in operation.responses) {
      if (statusCode.startsWith("2")) {
        const response = operation.responses[statusCode] as OpenAPIV3.ResponseObject;
        const primarySuccessCode = method === "post" ? "201" : "200";
        const isPrimary = statusCode === primarySuccessCode;
        if (response && "content" in response && response.content?.["application/json"]?.schema) {
          const responseSchema = response.content["application/json"].schema;
          const typeName = `${typeBaseName}_Response${isPrimary ? "" : `_${statusCode}`}`;
          if (isPrimary) primaryResponseTypeName = typeName;
          if (!generatedTypeNames.has(typeName)) {
            try {
              const tsType = await compile(responseSchema as JSONSchema, typeName, { bannerComment: "" });
              typesContent += `\n${tsType}\n`;
              generatedTypeNames.add(typeName);
              if (isPrimary) primaryResponseTypeGenerated = true;
            } catch (err: any) {
              const errMsg = err.message;
              console.warn(
                `    [${tagName}] Failed to generate response type ${typeName} (status ${statusCode}): ${errMsg}`
              );
              typesContent += `\n// ⚠️ Type generation failed for ${typeName} (status ${statusCode}): ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
              if (isPrimary) responseTypeFailed = true;
            }
          } else {
            if (isPrimary) primaryResponseTypeGenerated = true;
          }
        } else if (isPrimary && !response?.content) {
          primaryResponseTypeName = "void";
          primaryResponseTypeGenerated = true;
        } else if (isPrimary) {
          console.warn(
            `    [${tagName}] No content schema for primary success ${primarySuccessCode} for ${functionName}.`
          );
          responseTypeFailed = true;
        }
      }
    }

    // --- Generate Parameters Type ---
    const queryParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "query"
      ) as OpenAPIV3.ParameterObject[]) || [];
    if (queryParams && queryParams.length > 0) {
      const paramsSchema: JSONSchema = { type: "object", properties: {}, required: [] };
      queryParams.forEach((p) => {
        if (paramsSchema.properties) {
          paramsSchema.properties[p.name] = p.schema || { type: "string" };
          if (p.required) {
            if (!Array.isArray(paramsSchema.required)) {
              paramsSchema.required = [];
            }
            paramsSchema.required.push(p.name);
          }
        }
      });
      if (Object.keys(paramsSchema.properties || {}).length > 0) {
        const typeName = `${typeBaseName}_Parameters`;
        actualParametersTypeName = typeName;
        if (!generatedTypeNames.has(typeName)) {
          try {
            const tsType = await compile(paramsSchema, typeName, { bannerComment: "", additionalProperties: false });
            typesContent += `\n${tsType}\n`;
            generatedTypeNames.add(typeName);
          } catch (err: any) {
            const errMsg = err.message;
            console.warn(`    [${tagName}] Failed to generate parameters type ${typeName}: ${errMsg}`);
            typesContent += `\n// ⚠️ Type generation failed for ${typeName}: ${errMsg}\n// Check the OpenAPI spec, especially $refs.\n`;
            actualParametersTypeName = null;
            parametersTypeFailed = true;
          }
        }
      }
    }

    // --- Assemble Function Factory ---
    const pathParams =
      (operation.parameters?.filter(
        (p) => (p as OpenAPIV3.ParameterObject).in === "path"
      ) as OpenAPIV3.ParameterObject[]) || [];

    const factoryInnerFuncParamsList: string[] = [];
    pathParams.forEach((p) => {
      factoryInnerFuncParamsList.push(`${toTsIdentifier(p.name)}: string`);
    });

    let requestBodyTypeForFunc: string | null = null;
    if (actualRequestBodyTypeName) {
      requestBodyTypeForFunc = `${tagImportName}.${actualRequestBodyTypeName}`;
      factoryInnerFuncParamsList.push(`data: ${requestBodyTypeForFunc}`);
    }

    let queryParamsTypeForFunc: string | null = null;
    if (actualParametersTypeName) {
      queryParamsTypeForFunc = `${tagImportName}.${actualParametersTypeName}`;
      factoryInnerFuncParamsList.push(`params?: ${queryParamsTypeForFunc}`);
    }

    // Add callSpecificOptions to the inner function
    // Omitting fields that are set by the factory itself
    const callSpecificOptionsType = `Partial<Omit<SGSyncRequesterOptions, 'method' | 'url' | 'authRequire'${requestBodyTypeForFunc ? " | 'data'" : ""}${queryParamsTypeForFunc ? " | 'params'" : ""}>>`;
    factoryInnerFuncParamsList.push(`callSpecificOptions?: ${callSpecificOptionsType}`);

    const factoryInnerFuncParamsString = factoryInnerFuncParamsList.join(",\n    ");
    const urlPath = path.replace(/{([^}]+)}/g, (match, paramName) => `\${toTsIdentifier(paramName)}`);

    let finalResponseTypeNameForSig: string;
    let responseTypeForSGSyncResponse: string;

    if (primaryResponseTypeGenerated) {
      if (primaryResponseTypeName === "void") {
        finalResponseTypeNameForSig = "void";
        responseTypeForSGSyncResponse = "void";
      } else if (primaryResponseTypeName) {
        finalResponseTypeNameForSig = `${tagImportName}.${primaryResponseTypeName}`;
        responseTypeForSGSyncResponse = finalResponseTypeNameForSig;
      } else {
        finalResponseTypeNameForSig = "any";
        responseTypeForSGSyncResponse = "any";
      }
    } else {
      finalResponseTypeNameForSig = "any";
      responseTypeForSGSyncResponse = "any";
    }

    let functionComment = "";
    if (requestBodyFailed) {
      functionComment += `// ⚠️ WARNING: Request Body type generation failed. 'data' parameter type may be incorrect.\n`;
    }
    if (parametersTypeFailed) {
      functionComment += `// ⚠️ WARNING: Parameters type generation failed. 'params' parameter type may be incorrect.\n`;
    }
    if (responseTypeFailed || (!primaryResponseTypeGenerated && primaryResponseTypeName !== "void")) {
      functionComment += `// ⚠️ WARNING: Response type generation failed or schema missing. Expected response type is '${responseTypeForSGSyncResponse}'.\n`;
    }

    let functionString = "";
    if (functionComment) {
      functionString += `\n${functionComment}`;
    }
    functionString += `\n\n${operationGroupBanner}\n`;
    functionString += `/**\n * Factory for a function to call ${summary}\n`;
    if (operation.description && operation.description !== summary) {
      functionString += ` * ${operation.description.replace(/\n/g, "\n * ")}\n`;
    }
    functionString += ` * @param requester The SGSyncRequester instance to use for making the actual HTTP request.\n`;
    functionString += ` */\n`;
    // Note: baseFunctionName is what the user will call, functionFactoryName is the exported factory.
    functionString += `export const ${functionName} = (requester: SGSyncRequester) => {\n`;
    functionString += `  /**\n   * ${summary}\n   */\n`;
    functionString += `  return async (\n    ${factoryInnerFuncParamsString}\n  ): Promise<SGSyncResponse<${responseTypeForSGSyncResponse}>> => {\n`;
    functionString += `    const path = \`${urlPath}\`;\n`;
    functionString += `    const options: SGSyncRequesterOptions = {\n`;
    functionString += `      method: '${method}',\n`;
    functionString += `      url: path,\n`;
    functionString += `      authRequire: ${authRequire},`;
    if (queryParamsTypeForFunc) {
      functionString += `
      params: params,`;
    }
    if (requestBodyTypeForFunc) {
      functionString += `
      data: data,`;
    }
    functionString += `
      ...(callSpecificOptions || {}),
    };\n`;
    functionString += `    return requester<${responseTypeForSGSyncResponse}>(options);\n`;
    functionString += `  };\n`;
    functionString += `};\n`;

    functionsContent += functionString;
    functionFactoryNames.push(functionName);

    // --- Generate React Query Hook Factory (if enabled) ---
    if (reactQueryEnabled) {
      console.log(`    [RQ Enabled] Generating hook factory for ${functionName}`);
      let hookFactoryString = "";
      const queryHookParamsList: string[] = []; // Parameters for the inner hook function
      const pathParamNames = pathParams.map((p) => toTsIdentifier(p.name));

      pathParams.forEach((p) => {
        queryHookParamsList.push(`${toTsIdentifier(p.name)}: string`);
      });

      let actualParamsTypeForHookCall: string | null = null;
      if (actualParametersTypeName) {
        actualParamsTypeForHookCall = `${tagImportName}.${actualParametersTypeName}`;
        queryHookParamsList.push(`params?: ${actualParamsTypeForHookCall}`);
      }

      let finalDataResponseTypeForHook: string = responseTypeForSGSyncResponse; // This is T in SGSyncResponse<T>
      if (finalDataResponseTypeForHook === "void") finalDataResponseTypeForHook = "unknown"; // TanStack Query data type cannot be void, use unknown

      const operationGroupBannerForHook = createOperationGroupBanner(operation.summary, method, path);
      hookFactoryString += `\n\n${operationGroupBannerForHook}\n`;
      hookFactoryString += `/**\n * Factory for a TanStack Query ${method === "get" ? "useQuery" : "useMutation"} hook for ${summary}\n`;
      hookFactoryString += ` * @param requester The SGSyncRequester instance to use for making the actual HTTP request.\n`;
      hookFactoryString += ` */\n`;
      hookFactoryString += `export const ${hookBaseName} = (requester: SGSyncRequester) => {\n`;
      // Instantiate the API function using its factory
      hookFactoryString += `  const ${functionName}Function = ${functionName}(requester);\n\n`;

      if (method === "get") {
        // Add callSpecificOptions for the query hook, but only for relevant parts of SGSyncRequesterOptions (e.g. headers)
        const queryCallSpecificOptionsType = `Partial<Omit<SGSyncRequesterOptions, 'method' | 'url' | 'authRequire' | 'data'${queryParamsTypeForFunc ? " | 'params'" : ""}>>`;
        queryHookParamsList.push(`callSpecificOptions?: ${queryCallSpecificOptionsType}`);
        queryHookParamsList.push(
          `options?: Omit<UseQueryOptions<${finalDataResponseTypeForHook}, AxiosError, ${finalDataResponseTypeForHook}, QueryKey>, 'queryKey' | 'queryFn'>`
        );
        const queryKeyParts = [`'${sanitizedTagName}'`, `'${endpointBaseName}'`];
        if (pathParamNames.length > 0) {
          queryKeyParts.push(`{ ${pathParamNames.join(", ")} }`);
        }
        if (actualParametersTypeName) {
          queryKeyParts.push("params");
        }
        // queryKeyParts.push("callSpecificOptions"); // Consider if callSpecificOptions should affect queryKey

        hookFactoryString += `  /**\n   * TanStack Query useQuery hook for ${summary}\n   */\n`;
        hookFactoryString += `  return (\n    ${queryHookParamsList.join(",\n    ")}\n  ) => {\n`;
        hookFactoryString += `    const queryKey: QueryKey = [${queryKeyParts.join(", ")}];\n\n`;
        hookFactoryString += `    return useQuery<${finalDataResponseTypeForHook}, AxiosError, ${finalDataResponseTypeForHook}, QueryKey>({
`;
        hookFactoryString += `      queryKey,
`;
        hookFactoryString += `      queryFn: async () => {\n`;
        const baseFuncArgsList: string[] = [...pathParamNames];
        if (actualParametersTypeName) {
          baseFuncArgsList.push("params");
        }
        baseFuncArgsList.push("callSpecificOptions"); // Pass it to the underlying function call
        hookFactoryString += `        const response = await ${functionName}Function(${baseFuncArgsList.join(", ")});\n`;
        hookFactoryString += `        if (response.status >= 200 && response.status < 300) {
`;
        hookFactoryString += `          return response.data;
`;
        hookFactoryString += `        } else {
`;
        hookFactoryString += `          throw new AxiosError(
`;
        hookFactoryString += `            response.statusText || 'Request failed',
`;
        hookFactoryString += `            String(response.status),
`;
        hookFactoryString += `            response.config as any, // This might not be perfect AxiosRequestConfig
`;
        hookFactoryString += `            null, // request object
`;
        hookFactoryString += `            response as any // response object 
`;
        hookFactoryString += `          );
`;
        hookFactoryString += `        }
`;
        hookFactoryString += `      },
`;
        hookFactoryString += `      ...options,
`;
        hookFactoryString += `    });\n`;
        hookFactoryString += `  };\n`;
      } else {
        // POST, PUT, PATCH, DELETE for useMutation
        let mutationVariablesType = "void";
        const mutationVariablesParts: string[] = [];
        // Path params are part of the variables if not part of the hook's direct signature (which they usually are for mutations)
        pathParamNames.forEach((pName) => mutationVariablesParts.push(`${pName}: string`));
        if (actualRequestBodyTypeName) {
          mutationVariablesParts.push(`data: ${tagImportName}.${actualRequestBodyTypeName}`);
        }
        if (actualParametersTypeName) {
          mutationVariablesParts.push(`params?: ${tagImportName}.${actualParametersTypeName}`);
        }
        // Add callSpecificOptions for the mutation hook
        const mutationCallSpecificOptionsType = `Partial<Omit<SGSyncRequesterOptions, 'method' | 'url' | 'authRequire'${requestBodyTypeForFunc ? " | 'data'" : ""}${queryParamsTypeForFunc ? " | 'params'" : ""}>>`;
        mutationVariablesParts.push(`callSpecificOptions?: ${mutationCallSpecificOptionsType}`);

        if (mutationVariablesParts.length > 0) {
          mutationVariablesType = `{ ${mutationVariablesParts.join("; ")} }`;
        }

        const mutationHookParamsList = [
          `options?: Omit<UseMutationOptions<${finalDataResponseTypeForHook}, AxiosError, ${mutationVariablesType}>, 'mutationFn'>`,
        ];

        hookFactoryString += `  /**\n   * TanStack Query useMutation hook for ${summary}\n   */\n`;
        hookFactoryString += `  return (\n    ${mutationHookParamsList.join(",\n    ")}\n  ) => {\n`;
        hookFactoryString += `    return useMutation<${finalDataResponseTypeForHook}, AxiosError, ${mutationVariablesType}>({
`;
        hookFactoryString += `      mutationFn: async (variables) => {\n`;
        const baseFuncArgsList: string[] = [];
        pathParamNames.forEach((pName) => baseFuncArgsList.push(`variables.${pName}`));
        if (actualRequestBodyTypeName) {
          baseFuncArgsList.push("variables.data");
        }
        if (actualParametersTypeName) {
          baseFuncArgsList.push("variables.params");
        }
        baseFuncArgsList.push("variables.callSpecificOptions");

        hookFactoryString += `        const response = await ${functionName}Function(${baseFuncArgsList.join(", ")});\n`;
        hookFactoryString += `        if (response.status >= 200 && response.status < 300) {
`;
        hookFactoryString += `          return response.data;
`;
        hookFactoryString += `        } else {
`;
        hookFactoryString += `          throw new AxiosError(
`;
        hookFactoryString += `            response.statusText || 'Request failed',
`;
        hookFactoryString += `            String(response.status),
`;
        hookFactoryString += `            response.config as any, // This might not be perfect AxiosRequestConfig
`;
        hookFactoryString += `            null, // request object
`;
        hookFactoryString += `            response as any // response object
`;
        hookFactoryString += `          );
`;
        hookFactoryString += `        }
`;
        hookFactoryString += `      },
`;
        hookFactoryString += `      ...options,
`;
        hookFactoryString += `    });\n`;
        hookFactoryString += `  };\n`;
      }
      hookFactoryString += `};\n`;

      if (hookFactoryString.trim()) {
        hooksContent += hookFactoryString;
        hooksGenerated = true;
        hookFactoryNames.push(hookBaseName);
      } else {
        console.log(`    [RQ] No hook factory string generated for ${functionName}`);
      }
    }
  } // End loop through operations

  // --- Add Imports to hooksContent if needed ---
  if (reactQueryEnabled && hooksGenerated) {
    let hookImports = `// Imports for TanStack Query, error types, and requester mechanism\n`;
    hookImports += `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions, QueryKey } from '@tanstack/react-query';\n`;
    hookImports += `import { AxiosError } from 'axios'; // Assuming AxiosError for error type\n`;
    hookImports += `import { SGSyncRequester, SGSyncRequesterOptions, SGSyncResponse } from './requester-types';\n`;
    hookImports += `import * as ${tagImportName} from './types';\n`;

    if (functionFactoryNames.length > 0) {
      // Ensure no trailing comma for single or last item
      let factoryImportStatements = "  " + functionFactoryNames.join(",\n  ");
      hookImports += `import {\n${factoryImportStatements}\n} from './functions';\n\n`;
    }

    const hooksTopBanner = createTopLevelBanner("hooks");
    // Ensure hooksContent itself is valid before prepending imports
    hooksContent = `${hooksTopBanner}\n\n${hookImports}${hooksContent}`;
  } else if (reactQueryEnabled) {
    console.log("  [RQ Summary] React Query enabled, but no hook factories were generated for this tag.");
  }

  return { typesContent, functionsContent, hooksContent, functionFactoryNames, hookFactoryNames };
}
