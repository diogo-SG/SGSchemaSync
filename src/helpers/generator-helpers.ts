// src/helpers/generator-helpers.ts

// Helper to generate a TS identifier (e.g., for function names, types)
export function toTsIdentifier(str: string): string {
  if (!str) return "_"; // Handle empty or null strings
  // Remove leading/trailing non-alphanumeric, replace separators with underscores
  const cleaned = str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "").replace(/[^a-zA-Z0-9_]+/g, "_");
  // Ensure it starts with a letter or underscore if the first char was numeric or if empty after cleaning
  if (!cleaned || /^[0-9]/.test(cleaned)) {
    return `_${cleaned}`;
  }
  return cleaned;
}

// Helper to generate a PascalCase type name
export function toPascalCase(str: string): string {
  if (!str) return "Type"; // Handle empty or null strings
  // Correctly handle splitting and mapping
  return str
    .split(/[^a-zA-Z0-9]/)
    .map((part) => (part ? part.charAt(0).toUpperCase() + part.slice(1) : ""))
    .join("");
}

// Helper for path-based base name (Revised to include parameter info)
export function getPathBasedBaseName(path: string): string {
  // Remove common prefixes /api/, /v1/, or just leading slash
  const cleanedPath = path.replace(/^\/(api|v\d+)\/|^\//, "");

  // Split segments and handle parameters
  const segments = cleanedPath.split("/").map((seg) => {
    if (seg.startsWith("{") && seg.endsWith("}")) {
      // Convert {paramName} to ByParamName
      const paramName = seg.slice(1, -1);
      return `By${toPascalCase(paramName)}`;
    } else {
      // Convert normal segment to PascalCase
      return toPascalCase(seg);
    }
  });

  const joined = segments.join("");

  // Handle cases where the path might become empty after processing
  if (!joined) return "RootOperation"; // Fallback

  return joined;
}

// --- Banner Formatting Helpers ---
export const GENERATOR_NAME = "sg-schema-sync";
const BANNER_WIDTH = 74;

export function createTopLevelBanner(fileType: "types" | "functions" | "hooks" | "index"): string {
  const line = "*".repeat(BANNER_WIDTH + 1);
  const date = new Date().toISOString();
  const text = `Generated ${fileType} by ${GENERATOR_NAME} on ${date}`;
  const warning = "DO NOT EDIT THIS FILE MANUALLY. IT WILL BE OVERWRITTEN.";

  const centerText = (str: string) => {
    const padding = Math.max(0, BANNER_WIDTH - str.length);
    const left = Math.floor(padding / 2);
    const right = padding - left;
    return ` ${" ".repeat(left)}${str}${" ".repeat(right)} `;
  };

  return `/*${line}\n *${centerText(text)}*\n *${centerText(warning)}*\n ${line}*/`;
}

export function createOperationGroupBanner(
  summary: string | undefined,
  method: string,
  path: string,
  char: string = "-"
): string {
  const routeText = `${method.toUpperCase()} ${path}`;
  const summaryText = summary ? ` - ${summary}` : "";
  const fullText = `${routeText}${summaryText}`;
  const lineLength = Math.max(BANNER_WIDTH, fullText.length + 4);
  const line = char.repeat(lineLength);

  // Center the text within the line
  const paddingTotal = lineLength - fullText.length - 2; // -2 for spaces around text
  const paddingLeft = Math.floor(paddingTotal / 2);
  const paddingRight = paddingTotal - paddingLeft; // Use this instead of ceil for exact width
  const paddedText = `${char.repeat(paddingLeft)} ${fullText} ${char.repeat(paddingRight)}`;

  return `\n/*${line}*/\n/*${paddedText}*/\n/*${line}*/`;
}
// --- End Banner Formatting Helpers ---
