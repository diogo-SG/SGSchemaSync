import fs from "fs/promises";
import path from "path";

// More robust regex for the top-level banner containing the timestamp.
// Matches /* at start of line, non-greedily includes everything until */,
// ensuring 'Generated by sg-schema-sync' is present. Allows optional trailing newline.
const generatedBannerRegex = /^\/\*[\s\S]*?Generated by sg-schema-sync[\s\S]*?\*\/(\n)?/m;

// Matches the /* eslint-disable */ and standard DO NOT MODIFY block
const standardCommentBlockRegex =
  /^\/\*\s*eslint-disable\s*\*\/\s*[\r\n]+\/\*\*\s*[\r\n]+\s*\*\s*This file was automatically generated by sg-schema-sync\.\s*[\r\n]+\s*\*\s*DO NOT MODIFY IT BY HAND\..*\s*[\r\n]+\s*\*\/\s*[\r\n]*/m;

// Matches the dynamically added warning comments about type generation failures
const typeGenWarningCommentRegex = /^\s*\/\/\s*⚠️\s*Type generation failed.*$[\r\n]*/gm;

// Matches the warning comments added inside functions/hooks when generation fails
const funcHookWarningCommentRegex =
  /^\s*\/\/\s*⚠️\s*WARNING: (?:Request Body|Parameters|Response) type generation failed.*$[\r\n]*/gm;

/**
 * Removes known generated header comments and banners from file content.
 * Also normalizes line endings to LF (\n).
 * @param content The file content.
 * @returns Content without headers/banners and with normalized line endings.
 */
function stripGeneratedHeadersAndNormalize(content: string): string {
  // 1. Normalize line endings first for consistent processing
  let normalizedContent = content.replace(/\r\n/g, "\n");

  // --- BEGIN DEBUG LOGGING ---
  // console.log("[Debug FS] Before top banner strip:\n", normalizedContent.substring(0, 300));
  // --- END DEBUG LOGGING ---

  // 2. Remove top-level banners/comments using regex
  const contentBeforeReplace = normalizedContent; // Store before replace
  normalizedContent = normalizedContent.replace(generatedBannerRegex, "");

  // --- BEGIN DEBUG LOGGING ---
  if (contentBeforeReplace === normalizedContent && generatedBannerRegex.test(contentBeforeReplace)) {
    console.error("[Debug FS Error] generatedBannerRegex matched but replace had no effect!");
  } else if (!generatedBannerRegex.test(contentBeforeReplace)) {
    console.warn("[Debug FS Warn] generatedBannerRegex did not match the content.");
  }
  // console.log("[Debug FS] After top banner strip:\n", normalizedContent.substring(0, 300));
  // --- END DEBUG LOGGING ---

  normalizedContent = normalizedContent.replace(standardCommentBlockRegex, "");

  // 3. Remove single-line warning comments using regex
  normalizedContent = normalizedContent.replace(typeGenWarningCommentRegex, "");
  normalizedContent = normalizedContent.replace(funcHookWarningCommentRegex, "");

  // 4. REMOVED: Line-by-line filtering for operation banners is no longer needed
  //    as the timestamp is in the top-level banner handled by generatedBannerRegex.

  // 5. Trim whitespace from the final result
  return normalizedContent.trim();
}

/**
 * Writes content to a file only if the significant content (excluding known headers/banners) has changed.
 * Creates the directory if it doesn't exist.
 *
 * @param filePath Absolute path to the file.
 * @param newContent The new content to potentially write.
 * @param verbose Whether to log skipped writes.
 * @returns Promise<boolean> True if the file was written, false otherwise.
 */
export async function writeFileIfChanged(filePath: string, newContent: string, verbose: boolean): Promise<boolean> {
  let existingContentStripped = "";
  let fileExists = false;

  try {
    const existingContent = await fs.readFile(filePath, "utf-8");
    existingContentStripped = stripGeneratedHeadersAndNormalize(existingContent);
    fileExists = true;
  } catch (error: any) {
    if (error.code !== "ENOENT") {
      console.error(`Error reading existing file ${filePath}:`, error);
      throw error; // Re-throw unexpected errors
    }
    // File doesn't exist, which is fine.
  }

  const newContentStripped = stripGeneratedHeadersAndNormalize(newContent);

  if (fileExists && existingContentStripped === newContentStripped) {
    if (verbose) {
      console.log(`  -> Content unchanged, skipping write: ${filePath}`);
    }
    return false; // Indicate file was not written
  } else {
    if (verbose && fileExists) {
      console.log(`------------------------------------------------------------`);
      console.log(`[Debug] Content differs for: ${filePath}`);
      console.log(`[Debug] Comparing Existing (Stripped) vs. New (Stripped):`);
      const MAX_LOG_LEN = 500; // Limit log length
      console.log(`  Existing Len: ${existingContentStripped.length}, New Len: ${newContentStripped.length}`);

      if (existingContentStripped !== newContentStripped) {
        let diffIndex = -1;
        for (let i = 0; i < Math.min(existingContentStripped.length, newContentStripped.length); i++) {
          if (existingContentStripped[i] !== newContentStripped[i]) {
            diffIndex = i;
            break;
          }
        }
        if (diffIndex !== -1) {
          console.log(`  First difference found around index: ${diffIndex}`);
          const snippetContext = 20;
          console.log(
            `    Existing near diff: ...${existingContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${existingContentStripped[diffIndex] || ""}]${existingContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
          console.log(
            `    New near diff:      ...${newContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${newContentStripped[diffIndex] || ""}]${newContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
        } else if (existingContentStripped.length !== newContentStripped.length) {
          console.log(`  Difference is primarily in length.`);
        }
      }

      console.log(`------------------------------------------------------------`);
    }

    await fs.mkdir(path.dirname(filePath), { recursive: true }); // Ensure directory exists
    await fs.writeFile(filePath, newContent, "utf-8");
    const action = fileExists ? "Overwritten" : "Written";
    console.log(`  -> ${action}: ${filePath}`);
    return true; // Indicate file was written
  }
}
