import fs from "fs/promises";
import path from "path";

// Matches the /* Generated by ... */ banner, accounting for multi-line if needed
const generatedBannerRegex = /^\/\*\s*Generated by sg-schema-sync for [^*]+\*\/[\r\n]*/m;
// Matches the /* eslint-disable */ and standard DO NOT MODIFY block
const standardCommentBlockRegex =
  /^\/\*\s*eslint-disable\s*\*\/\s*[\r\n]+\/\*\*\s*[\r\n]+\s*\*\s*This file was automatically generated by sg-schema-sync\.\s*\r\n]+\s*\*\s*DO NOT MODIFY IT BY HAND\..*\s*[\r\n]+\s*\*\/\s*[\r\n]*/m;

// Matches the dynamically added warning comments about type generation failures
const typeGenWarningCommentRegex = /^\s*\/\/\s*⚠️\s*Type generation failed for.*$[\r\n]*/gm;

// Matches the warning comments added inside functions/hooks when generation fails
const funcHookWarningCommentRegex =
  /^\s*\/\/\s*⚠️\s*WARNING: (?:Request Body|Parameters|Response) type generation failed.*$[\r\n]*/gm;

// Matches the operation group banners added between operations
const operationGroupBannerRegex = /^\s*\/\*---\s*[\r\n]+(?:\s*\*.*[\r\n]+)+\s*\*---\*\/\s*[\r\n]*/gm;

/**
 * Removes known generated header comments from file content.
 * Also normalizes line endings to LF (\n).
 * @param content The file content.
 * @returns Content without headers and with normalized line endings.
 */
function stripGeneratedHeadersAndNormalize(content: string): string {
  let stripped = content.replace(generatedBannerRegex, "");
  stripped = stripped.replace(standardCommentBlockRegex, "");
  stripped = stripped.replace(typeGenWarningCommentRegex, "");
  stripped = stripped.replace(funcHookWarningCommentRegex, "");
  stripped = stripped.replace(operationGroupBannerRegex, "");
  return stripped.replace(/\r\n/g, "\n").trim(); // Normalize line endings and trim whitespace
}

/**
 * Writes content to a file only if the significant content (excluding known headers) has changed.
 * Creates the directory if it doesn't exist.
 *
 * @param filePath Absolute path to the file.
 * @param newContent The new content to potentially write.
 * @param verbose Whether to log skipped writes.
 * @returns Promise<boolean> True if the file was written, false otherwise.
 */
export async function writeFileIfChanged(filePath: string, newContent: string, verbose: boolean): Promise<boolean> {
  let existingContentStripped = "";
  let fileExists = false;

  try {
    const existingContent = await fs.readFile(filePath, "utf-8");
    existingContentStripped = stripGeneratedHeadersAndNormalize(existingContent);
    fileExists = true;
  } catch (error: any) {
    if (error.code !== "ENOENT") {
      console.error(`Error reading existing file ${filePath}:`, error);
      throw error; // Re-throw unexpected errors
    }
    // File doesn't exist, which is fine.
  }

  const newContentStripped = stripGeneratedHeadersAndNormalize(newContent);

  if (fileExists && existingContentStripped === newContentStripped) {
    if (verbose) {
      console.log(`  -> Content unchanged, skipping write: ${filePath}`);
    }
    return false; // Indicate file was not written
  } else {
    if (verbose && fileExists) {
      console.log(`------------------------------------------------------------`);
      console.log(`[Debug] Content differs for: ${filePath}`);
      console.log(`[Debug] Comparing Existing (Stripped) vs. New (Stripped):`);
      const MAX_LOG_LEN = 500; // Limit log length
      console.log(`  Existing Len: ${existingContentStripped.length}, New Len: ${newContentStripped.length}`);

      if (existingContentStripped !== newContentStripped) {
        let diffIndex = -1;
        for (let i = 0; i < Math.min(existingContentStripped.length, newContentStripped.length); i++) {
          if (existingContentStripped[i] !== newContentStripped[i]) {
            diffIndex = i;
            break;
          }
        }
        if (diffIndex !== -1) {
          console.log(`  First difference found around index: ${diffIndex}`);
          const snippetContext = 20;
          console.log(
            `    Existing near diff: ...${existingContentStripped.substring(Math.max(0, diffIndex - snippetContext), diffIndex)}[${existingContentStripped[diffIndex] || ""}]${existingContentStripped.substring(diffIndex + 1, diffIndex + 1 + snippetContext)}...`
          );
          console.log(
            `    New near diff:      ...${newContentStripped.substring(Math.max(0, diffIndex - snippetContext), diffIndex)}[${newContentStripped[diffIndex] || ""}]${newContentStripped.substring(diffIndex + 1, diffIndex + 1 + snippetContext)}...`
          );
        } else if (existingContentStripped.length !== newContentStripped.length) {
          console.log(`  Difference is primarily in length.`);
        }
      }

      console.log(`------------------------------------------------------------`);
    }

    await fs.mkdir(path.dirname(filePath), { recursive: true }); // Ensure directory exists
    await fs.writeFile(filePath, newContent, "utf-8");
    const action = fileExists ? "Overwritten" : "Written";
    console.log(`  -> ${action}: ${filePath}`);
    return true; // Indicate file was written
  }
}
