import fs from "fs/promises";
import path from "path";

// Matches the /* Generated by ... */ banner, accounting for multi-line if needed
const generatedBannerRegex = /^\/\*\s*Generated by sg-schema-sync for [^*]+\*\/[\r\n]*/m;
// Matches the /* eslint-disable */ and standard DO NOT MODIFY block
const standardCommentBlockRegex =
  /^\/\*\s*eslint-disable\s*\*\/\s*[\r\n]+\/\*\*\s*[\r\n]+\s*\*\s*This file was automatically generated by sg-schema-sync\.\s*[\r\n]+\s*\*\s*DO NOT MODIFY IT BY HAND\..*\s*[\r\n]+\s*\*\/\s*[\r\n]*/m;

// Matches the dynamically added warning comments about type generation failures
const typeGenWarningCommentRegex = /^\s*\/\/\s*⚠️\s*Type generation failed for.*$[\r\n]*/gm;

// Matches the warning comments added inside functions/hooks when generation fails
const funcHookWarningCommentRegex =
  /^\s*\/\/\s*⚠️\s*WARNING: (?:Request Body|Parameters|Response) type generation failed.*$[\r\n]*/gm;

/**
 * Removes known generated header comments and banners from file content.
 * Also normalizes line endings to LF (\n).
 * @param content The file content.
 * @returns Content without headers/banners and with normalized line endings.
 */
function stripGeneratedHeadersAndNormalize(content: string): string {
  // 1. Normalize line endings first for consistent processing
  let normalizedContent = content.replace(/\r\n/g, "\n");

  // 2. Remove top-level banners/comments using regex (these are reliable)
  normalizedContent = normalizedContent.replace(generatedBannerRegex, "");
  normalizedContent = normalizedContent.replace(standardCommentBlockRegex, "");

  // 3. Remove single-line warning comments using regex
  normalizedContent = normalizedContent.replace(typeGenWarningCommentRegex, "");
  normalizedContent = normalizedContent.replace(funcHookWarningCommentRegex, "");

  // 4. Remove multi-line /*--- ... ---*/ operation banners line by line (Revised Logic)
  const lines = normalizedContent.split("\n");
  const filteredLines: string[] = [];
  let insideOperationBanner = false;
  const bannerStartSimpleRegex = /^\s*\/\*---/; // Match start, allowing leading whitespace
  const bannerEndSimpleRegex = /\*---\*\/\s*$/; // Match end, allowing trailing whitespace
  const generatedOnLineRegex = /^\s*\*\s*Generated on:/; // Match the timestamp line

  for (const line of lines) {
    let skipLine = false;

    // Check start first
    if (bannerStartSimpleRegex.test(line)) {
      insideOperationBanner = true;
      skipLine = true; // Always skip the start line
      // If the same line also ends the banner, reset the flag immediately
      if (bannerEndSimpleRegex.test(line)) {
        insideOperationBanner = false;
      }
    }
    // If we are currently inside (and it wasn't the start line we just processed)
    else if (insideOperationBanner) {
      skipLine = true; // Skip this line
      // Check if this line ends the banner
      if (bannerEndSimpleRegex.test(line)) {
        insideOperationBanner = false; // Reset flag for the next line
      }
    }

    // Explicitly check for and skip the 'Generated on:' line, even if outside a banner (though unlikely)
    if (!skipLine && generatedOnLineRegex.test(line)) {
      skipLine = true;
    }

    // Only add the line if it wasn't skipped
    if (!skipLine) {
      filteredLines.push(line);
    }
  }

  // 5. Join lines back and trim whitespace
  return filteredLines.join("\n").trim();
}

/**
 * Writes content to a file only if the significant content (excluding known headers/banners) has changed.
 * Creates the directory if it doesn't exist.
 *
 * @param filePath Absolute path to the file.
 * @param newContent The new content to potentially write.
 * @param verbose Whether to log skipped writes.
 * @returns Promise<boolean> True if the file was written, false otherwise.
 */
export async function writeFileIfChanged(filePath: string, newContent: string, verbose: boolean): Promise<boolean> {
  let existingContentStripped = "";
  let fileExists = false;

  try {
    const existingContent = await fs.readFile(filePath, "utf-8");
    existingContentStripped = stripGeneratedHeadersAndNormalize(existingContent);
    fileExists = true;
  } catch (error: any) {
    if (error.code !== "ENOENT") {
      console.error(`Error reading existing file ${filePath}:`, error);
      throw error; // Re-throw unexpected errors
    }
    // File doesn't exist, which is fine.
  }

  const newContentStripped = stripGeneratedHeadersAndNormalize(newContent);

  if (fileExists && existingContentStripped === newContentStripped) {
    if (verbose) {
      console.log(`  -> Content unchanged, skipping write: ${filePath}`);
    }
    return false; // Indicate file was not written
  } else {
    if (verbose && fileExists) {
      console.log(`------------------------------------------------------------`);
      console.log(`[Debug] Content differs for: ${filePath}`);
      console.log(`[Debug] Comparing Existing (Stripped) vs. New (Stripped):`);
      const MAX_LOG_LEN = 500; // Limit log length
      console.log(`  Existing Len: ${existingContentStripped.length}, New Len: ${newContentStripped.length}`);

      if (existingContentStripped !== newContentStripped) {
        let diffIndex = -1;
        for (let i = 0; i < Math.min(existingContentStripped.length, newContentStripped.length); i++) {
          if (existingContentStripped[i] !== newContentStripped[i]) {
            diffIndex = i;
            break;
          }
        }
        if (diffIndex !== -1) {
          console.log(`  First difference found around index: ${diffIndex}`);
          const snippetContext = 20;
          console.log(
            `    Existing near diff: ...${existingContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${existingContentStripped[diffIndex] || ""}]${existingContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
          console.log(
            `    New near diff:      ...${newContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${newContentStripped[diffIndex] || ""}]${newContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
        } else if (existingContentStripped.length !== newContentStripped.length) {
          console.log(`  Difference is primarily in length.`);
        }
      }

      console.log(`------------------------------------------------------------`);
    }

    await fs.mkdir(path.dirname(filePath), { recursive: true }); // Ensure directory exists
    await fs.writeFile(filePath, newContent, "utf-8");
    const action = fileExists ? "Overwritten" : "Written";
    console.log(`  -> ${action}: ${filePath}`);
    return true; // Indicate file was written
  }
}
