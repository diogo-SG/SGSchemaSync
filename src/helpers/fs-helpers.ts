import fs from "fs/promises";
import path from "path";

// Matches the /* eslint-disable */ and standard DO NOT MODIFY block
const standardCommentBlockRegex =
  /^\/\*\s*eslint-disable\s*\*\/\s*[\r\n]+\/\*\*\s*[\r\n]+\s*\*\s*This file was automatically generated by sg-schema-sync\.\s*[\r\n]+\s*\*\s*DO NOT MODIFY IT BY HAND\..*\s*[\r\n]+\s*\*\/\s*[\r\n]*/m;

// Matches the dynamically added warning comments about type generation failures
const typeGenWarningCommentRegex = /^\s*\/\/\s*⚠️\s*Type generation failed.*$[\r\n]*/gm;

// Matches the warning comments added inside functions/hooks when generation fails
const funcHookWarningCommentRegex =
  /^\s*\/\/\s*⚠️\s*WARNING: (?:Request Body|Parameters|Response) type generation failed.*$[\r\n]*/gm;

/**
 * Removes known generated header comments and banners from file content.
 * Also normalizes line endings to LF (\n).
 * @param content The file content.
 * @returns Content without headers/banners and with normalized line endings.
 */
function stripGeneratedHeadersAndNormalize(content: string): string {
  // 1. Normalize line endings first for consistent processing
  let normalizedContent = content.replace(/\r\n/g, "\n");

  // 2. Remove eslint/standard comment blocks first using regex
  normalizedContent = normalizedContent.replace(standardCommentBlockRegex, "");

  // 3. Remove single-line warning comments using regex
  normalizedContent = normalizedContent.replace(typeGenWarningCommentRegex, "");
  normalizedContent = normalizedContent.replace(funcHookWarningCommentRegex, "");

  // 4. Filter out the top-level banner lines line-by-line
  const lines = normalizedContent.split("\n");
  const filteredLines: string[] = [];
  // Define patterns for the banner structure
  const bannerLine1Pattern = /^\/\*+$/; // Line 1: /* followed only by *
  const bannerLine2Regex = /^\*\s+Generated/; // Regex for timestamp line: *, one or more spaces, Generated
  const bannerLine3Start = " * DO NOT EDIT"; // Start of warning line
  const bannerLine4Pattern = /^ \*+\*\/$/; // Line 4: Space, one or more *, */

  for (const line of lines) {
    const trimmedLine = line.trim();
    // Skip lines matching the specific banner structure
    if (
      bannerLine1Pattern.test(trimmedLine) ||
      bannerLine2Regex.test(trimmedLine) || // Use regex for timestamp line
      trimmedLine.startsWith(bannerLine3Start) ||
      bannerLine4Pattern.test(line) // Use original line for pattern with leading space
    ) {
      continue; // Skip this banner line
    }
    filteredLines.push(line);
  }

  // 5. Join lines back and trim whitespace from the final result
  return filteredLines.join("\n").trim();
}

/**
 * Writes content to a file only if the significant content (excluding known headers/banners) has changed.
 * Creates the directory if it doesn't exist.
 *
 * @param filePath Absolute path to the file.
 * @param newContent The new content to potentially write.
 * @param verbose Whether to log skipped writes.
 * @returns Promise<boolean> True if the file was written, false otherwise.
 */
export async function writeFileIfChanged(filePath: string, newContent: string, verbose: boolean): Promise<boolean> {
  let existingContentStripped = "";
  let fileExists = false;

  try {
    const existingContent = await fs.readFile(filePath, "utf-8");
    existingContentStripped = stripGeneratedHeadersAndNormalize(existingContent);
    fileExists = true;
  } catch (error: any) {
    if (error.code !== "ENOENT") {
      console.error(`Error reading existing file ${filePath}:`, error);
      throw error; // Re-throw unexpected errors
    }
    // File doesn't exist, which is fine.
  }

  const newContentStripped = stripGeneratedHeadersAndNormalize(newContent);

  if (fileExists && existingContentStripped === newContentStripped) {
    if (verbose) {
      console.log(`  -> Content unchanged, skipping write: ${filePath}`);
    }
    return false; // Indicate file was not written
  } else {
    if (verbose && fileExists) {
      console.log(`------------------------------------------------------------`);
      console.log(`[Debug] Content differs for: ${filePath}`);
      console.log(`[Debug] Comparing Existing (Stripped) vs. New (Stripped):`);
      const MAX_LOG_LEN = 500; // Limit log length
      console.log(`  Existing Len: ${existingContentStripped.length}, New Len: ${newContentStripped.length}`);

      if (existingContentStripped !== newContentStripped) {
        let diffIndex = -1;
        for (let i = 0; i < Math.min(existingContentStripped.length, newContentStripped.length); i++) {
          if (existingContentStripped[i] !== newContentStripped[i]) {
            diffIndex = i;
            break;
          }
        }
        if (diffIndex !== -1) {
          console.log(`  First difference found around index: ${diffIndex}`);
          const snippetContext = 20;
          console.log(
            `    Existing near diff: ...${existingContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${existingContentStripped[diffIndex] || ""}]${existingContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
          console.log(
            `    New near diff:      ...${newContentStripped.substring(
              Math.max(0, diffIndex - snippetContext),
              diffIndex
            )}[${newContentStripped[diffIndex] || ""}]${newContentStripped.substring(
              diffIndex + 1,
              diffIndex + 1 + snippetContext
            )}...`
          );
        } else if (existingContentStripped.length !== newContentStripped.length) {
          console.log(`  Difference is primarily in length.`);
        }
      }

      console.log(`------------------------------------------------------------`);
    }

    await fs.mkdir(path.dirname(filePath), { recursive: true }); // Ensure directory exists
    await fs.writeFile(filePath, newContent, "utf-8");
    const action = fileExists ? "Overwritten" : "Written";
    console.log(`  -> ${action}: ${filePath}`);
    return true; // Indicate file was written
  }
}
